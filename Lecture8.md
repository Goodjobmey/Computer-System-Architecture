## ISA Overview

Количество инструкций, поддерживаемых процессором, ограничено и фиксировано. В отличие от высокоуровневого программирования, где можно определять собственные функции, пользователь не может расширить набор машинных команд процессора.

На рынке существует множество различных микропроцессоров, каждый из которых реализует свой собственный набор команд. Одни и те же числовые коды интерпретируются по-разному в зависимости от архитектуры процессора. Например, в одной архитектуре код `501012` может обозначать команду `add r10, r12`, а в другой — `load r10, 12`.

Комбинация инструкций и доступных регистров формирует архитектуру набора команд процессора (Instruction Set Architecture, ISA). 

**Instruction Set Architecture (ISA)** — это абстрактная модель процессора, определяющая набор команд и правила их интерпретации и выполнения. ISA служит интерфейсом между аппаратной частью компьютера и программным обеспечением. Она задаёт формат команд, типы данных, способы адресации, доступные регистры и методы управления выполнением программ.

![ИСА](fig/isa-as-interface.png){ width=50% }

При разработке ISA аспекты производительности, энергопотребления и задержек, как правило, напрямую не учитываются — основное внимание сосредоточено на определении набора доступных средств для программирования.

Машинное слово — это единица данных фиксированного размера, обрабатываемая процессором как целостный фрагмент.

В рамках ISA команды процессора подразделяются на несколько основных категорий:
- **Инструкции работы с памятью**: запись констант в регистры, передача данных между памятью и регистрами процессора, а также обмен данными с внешними устройствами.
- **Арифметические и логические операции**: выполнение сложения, вычитания, умножения и деления с сохранением результата в регистрах; операции инкремента, декремента, побитовые операции (AND, OR, NOT), сдвиги битов, манипуляции отдельными битами, сравнение значений, а также поддержка вычислений с числами с плавающей точкой.
- **Управляющие инструкции**: безусловные и условные переходы, косвенные переходы, вызовы подпрограмм и возвраты из них.


### Аккумуляторная архитектура

Аккумуляторная архитектура возникла одной из первых, потому очень проста. В ней для хранения одного из операндов арифметической или логической операции в процессоре имеется выделенный регистр --- аккумулятор. В этот же регистр заносится и результат операции. Изначально оба операнда хранятся в основной памяти,и до выполнения операции один из них нужно загрузить в аккумулятор. После выполнения команды обработки результат находится в аккумуляторе и, если он не является операндом для последующей команды, его требуется сохранить в ячейке памяти.

Основные компоненты такой архитектуры включают:

- **Память** --- для считывания и записи данных;
- **АЛУ** (арифметико-логическое устройство) --- для выполнения операций;
- **Аккумулятор** --- специальная ячейка памяти, в которую можно многократно накапливать значения, изменяя их на основе ранее сохранённых данных.

**Пример выполнения вычислений**

В качестве примера рассматривается реализация классической линейной функции: 

`A = B + (C \times D)`

Процесс вычисления в аккумуляторной архитектуре выглядит следующим образом:

1. Инициализация аккумулятора значением переменной `C`.
2. Умножение содержимого аккумулятора на значение переменной `D`.
3. Прибавление к аккумулятору значения переменной `B`.
4. Сохранение конечного результата в адрес памяти, соответствующий переменной `A`.

Таким образом, весь вычислительный процесс строится вокруг последовательной работы с аккумулятором через простые шаги.

**Преимущества аккумуляторной архитектуры**
- **Простота системы команд**. Архитектура подразумевает минимальный набор инструкций: аккумулятор (неявный аргумент) и адрес памяти (явный аргумент).
- **Компактность инструкций**. Инструкции имеют фиксированный размер и малый объём.
- **Простота аппаратной реализации**. Реализация процессора становится крайне простой; основная сложность заключается лишь в организации работы с памятью.

**Ограничения аккумуляторной архитектуры**

Одним из ограничений является необходимость частой работы с памятью.  
Например, если бы в формуле использовалось другое действие:

`E = (A \times B) + (C \times D)`

то для хранения промежуточного результата понадобилась бы дополнительная ячейка памяти, так как аккумулятор смог бы удержать только одно промежуточное значение.

![Слайд презентации с аккумуляторной архитектурой](fig/proc-accum-arch.png)

**Пример системы команд и линейной функции Y = A * X + B:**

```
load ACC <- A.      ; acc
mul ACC <-* B
add ACC <-* C
store Y <- ACC
```

### Регистровая архитектура

Микропроцессор с архитектурой данного типа включает в себя массив регистров, известных как регистры общего назначения. В микропроцессоре отсутствует специальный регистр данных, выполняющий функции аккумулятора. Функции аккумулятора выполняет один из регистров общего назначения.

Размер регистров обычно фиксирован и совпадает с размером машинного слова. К любому регистру можно обратиться,указав его номер. Регистровая архитектура допускает расположение операндов в одном из двух пространств: основной памяти или регистрах. С учетом возможного размещения операндов в рамках регистровых архитектур выделяют три типа команд обработки: Register-to-Register, Register-to-Memory, Memory-to-Memory.


| Тип | Достоинства | Недостатки |
|----------|----------|----------|
| Register-to-Memory    | Данные могут быть доступны без загрузки в регистры процессора; простота кодирования команд; объектный код получается достаточно компактным   | Потеря одного из операндов при записи результата; длинное поле адреса памяти в коде команды сокращает место под номер регистра, что ограничивает общее число РОН. Количество тактов процессора, приходящихся на одну команду (CPI), зависит от места размещения операнда   |
| Register-to-Register    | Простота реализации; фиксиро­ванная длина команд; простая модель формирования объект­ного кода при компиляции программ; возможность выполне­ния всех команд за одинаковое количество тактов   | Большая длина объектного кода; из-за фиксированной длины команд часть разрядов в коротких командах не используется   |
| Memory-to-Memory    | Компактность объектного кода, малая потребность в регистрах для хранения промежуточных данных   | Разнообразие форматов команд и времени их исполнения, низкое быстродействие из-за обращения к памяти   |

#### Register-to-Memory

Логичным развитием аккумуляторной архитектуры является Register-to-Memory архитектура. По сути, она представляет собой эволюцию тех же идей, без кардинальных отличий от аккумуляторной модели, за исключением одного важного момента — введения большого количества регистров.

Основные особенности:
- **Увеличение числа регистров**. Множество регистров позволяет снизить нагрузку на память. Нет необходимости постоянно считывать и записывать данные между памятью и аккумулятором.Данные обрабатываются непосредственно в регистрах.

- **Расширение системы команд**. Один операнд указывает на регистр, с которым происходит операция. Два операнда позволяют разделить регистр-источник и регистр-назначение, повышая гибкость операций.

Рассмотрим задачу инкрементации массива чисел на фиксированное значение (например, на 2):

1. Значение `2` загружается в регистр `R0`.
2. Одно из значений массива загружается в регистр `R1`.
3. Выполняется сложение содержимого `R0` и `R1`.
4. Результат сохраняется в регистр `R2` (или обратно в память).
5. Операции повторяются для всех элементов массива в цикле.

Обе архитектуры **Accumulator** и **Register-to-Memory** стали основой развития вычислительных систем:

- Простота реализации на аппаратном уровне;
- Понятность программирования и написания машинного кода;
- Достаточная эффективность для базовых вычислительных задач.

Элементы **Register-to-Memory** архитектуры используются и в современных процессорах:  
многие современные архитектуры типа **CISC** во многом опираются на эти принципы.

**Пример системы команд и линейной функции Y = A * X + B:**

```
mul R1 <- A * B    ; reg-to-mem
add Y <- R1 + C    ; 2 operands 
```


#### Register-to-Register

В архитектуре **Register-to-Memory** на каждом такте выполняется доступ к памяти.  
Это является серьёзным недостатком, поскольку память почти всегда работает значительно медленнее, чем процессор и, тем более, чем регистры.

Проблема скорости доступа к памяти:
- **Процессор работает быстрее памяти**. Регистры имеют гораздо более высокую скорость доступа по сравнению с оперативной памятью.
- **Кэширование**. Современные процессоры применяют кэш-память для ускорения работы с оперативной памятью. Кэш позволяет быстрее получать доступ к небольшим фрагментам данных, но в случае отсутствия данных в кэше всё равно происходит медленный доступ к основной памяти.

По мере увеличения разрыва между скоростью процессоров и памяти возникла задача: 
Как сделать так, чтобы обращения к памяти происходили как можно реже?

Решением стало развитие архитектуры, в которой все операции выполняются **исключительно на регистрах**.

Принципы Register-to-Register архитектуры:
- **Предварительная загрузка данных**. Сначала необходимые данные считываются из памяти в регистры.
- **Вычисления только в регистрах**. Все арифметические и логические операции выполняются между регистрами без участия памяти.
- **Сохранение результатов**. После завершения вычислений результаты записываются обратно в память.

Преимущества Register-to-Register архитектуры:
- **Высокая скорость выполнения операций**. Операции на регистрах происходят значительно быстрее, так как регистры имеют мгновенный доступ.
-  **Эффективная схемотехника**. Поскольку регистров ограниченное количество, их можно эффективно связать мультиплексорами для быстрого выбора нужных данных.
-  **Минимизация времени выполнения инструкций**. Инструкции, работающие только с регистрами, могут выполняться за очень малое количество тактов (порой менее чем за два такта).
-  **Компактность инструкций**. Для адресации регистров требуется значительно меньше бит по сравнению с адресацией памяти. Например, если доступно 32 регистра, для указания каждого понадобится всего 5 бит. Таким образом, для указания двух операндов и результата достаточно 15 бит, а оставшееся место в инструкции используется для кодирования операции (опкода).

**Пример системы команд и линейной функции Y = A * X + B:**

```
load R1 <- A      ; reg-to-reg
load R2 <- X      ; 2 operands
load R3 <- В
mul R4 <- R1 * R2
add R5 <- R4 + R3
store Y <- R5     ;          
```

Здесь видно, что машинный код стал заметно больше по сравнению с первыми двумя вариантами. Это связано с тем, что мы чётко разделили операции работы с памятью и операции вычислений между регистрами.

Что получилось:
- Сначала мы загружаем данные в регистры отдельными командами load.
- Потом выполняем вычисления только между регистрами.
-  Результаты сохраняем через отдельный store.
-  Из-за такого подхода машинный код вырос, но мы получили несколько плюсов:
-  Стало проще отделять вычисления от работы с памятью.
-   Появилась возможность лучше организовать параллельную работу — например, пока одни данные загружаются, другие уже могут обрабатываться.
 Некоторые операции стали короче и проще, потому что они работают только с регистрами.

В общем, потеряли в компактности кода, но выиграли в чёткости структуры и потенциальной скорости выполнения.

#### Memory-to-Memory

После развития аккумуляторной и Register-to-Memory архитектур появились новые направления в организации вычислений, требующие ещё более глубокого управления памятью и инструкциями.

Одним из альтернативных путей развития стала **Memory-to-Memory** архитектура.

В этой модели инструкции работают напрямую с памятью:
- Инструкция считывает данные из одной ячейки памяти;
- Выполняет вычисления внутри процессора;
- Сохраняет результат обратно в другую ячейку памяти.

Фактически, одна инструкция объединяет несколько действий: чтение, вычисление и запись.

Преимущества Memory-to-Memory архитектуры:
- **Удобство для низкоуровневого программирования**. При разработке на ассемблере Memory-to-Memory архитектура позволяет писать код, который напрямую отражает алгоритмическую суть программы.
- **Эффективность инструкций**. Одна инструкция выполняет сразу несколько операций, что уменьшает накладные расходы на кодирование и интерпретацию инструкций.
- **Читаемость и простота отладки**. Программы на такой архитектуре легко читаются, а псевдокод высокого уровня можно почти напрямую транслировать в машинные инструкции.


Недостатки Memory-to-Memory архитектуры:
- **Большое количество обращений к памяти**. Частые операции чтения и записи в память замедляют выполнение программы, особенно с учётом того, что скорость памяти растёт медленнее, чем скорость процессоров.
- **Ограниченная эффективность кэширования**. Кэш-память частично помогает, но полностью проблему задержек при доступе к памяти устранить невозможно.
- **Сложность системы команд**. Архитектура Memory-to-Memory порождает богатую и разнообразную систему команд. Инструкции быстро обрастают дополнительной функциональностью (например, "прочитать и инкрементировать"). Реализация такой сложной логики на уровне аппаратуры требует значительных затрат ресурсов и времени.

**Пример системы команд и линейной функции Y = A * X + B:**

```
lnf Y<- A * B + C   ; mem-to-mem
                    ; 3 operands 
```

### Стековая архитектура

Отдельным направлением развития стала **стековая архитектура**. Стековая архитектура отличается компактностью команд и особенно эффективна для определённых типов вычислений (например, при реализации языков программирования с выражениями в польской записи). В её основе лежит принцип использования стековой памяти, размещённой непосредственно внутри процессора, вместо традиционного набора регистров. Стек представляет собой совокупность связанных между собой ячеек памяти, функционирующих по принципу «последним вошёл --- первым вышел» (LIFO, Last In First Out), что позволяет обращаться исключительно к элементу, находящемуся на вершине стека. Соответственно, в стековой архитектуре аргументы явно не указываются, а используются данные, размещённые на вершине стека.

**Преимущества стековой архитектуры**:
- **Естественная поддержка процедур**. Аргументы функций передаются посредством стека без необходимости использования ограниченного числа регистров, что особенно актуально при глубокой вложенности вызовов. Это избавляет от необходимости введения соглашений об использовании регистров, все необходимые данные просто помещаются в стек.
- **Простота реализации**. Стековая архитектура характеризуется простотой реализации и минималистичным машинным кодом, что упрощает проектирование процессоров.

**Недостатки стековой архитектуры**:
- **Неудобство произвольного доступа**. В случае необходимости обращения к элементам стека, расположенным не на вершине, возникает необходимость выполнения дополнительных операций, что приводит к увеличению количества команд. Для частичного решения этой проблемы могут использоваться несколько стеков или дополнительные регистры.
- **Сложности в оптимизации**. Ограничение работы только с вершиной стека затрудняет распараллеливание операций, что снижает производительность и ограничивает возможности ускорения выполнения программ.

Стековые процессоры часто применяются в реализации интерпретаторов, поскольку построение виртуальных машин на основе стека является удобным и эффективным решением.

**Пример системы команд и линейной функции Y = A * X + B:**

```
A @ X @ *   \ stack, 0 operands (7)
B @ + Y !   \ @ - read, ! - write 
```

## Машина фон-Неймана

Машина фон Неймана представляет собой абстрактную модель вычислительной системы, поскольку многие элементы её архитектуры изначально не были конкретизированы. Это сделано намеренно, чтобы не ограничивать творческий подход инженеров-разработчиков при создании новых ЭВМ. Таким образом, архитектура машины фон Неймана описана не на уровне внутренней реализации, а на концептуальном уровне представления вычислительного процесса.

Рассмотрим более конкретную организацию архитектуры фон Неймана:

![Машина фон Неймана](fig/von-neumann-example.png)

Описание:

- Разрядность процессора: 8 бит.
- Организация памяти: гарвардская, с отдельными блоками памяти для команд и данных.
- Внешние устройства (для данной работы это светодиоды, двухпозиционные переключатели и тактовые кнопки) отображаются в адресное пространство данных. Работа с ними выполняется по опросу.
- Регистры:
    - `PC` --- регистр счётчика команд (Program Counter) указывает адрес текущей инструкции, при этом общее количество возможных инструкций составляет 256.
    - `IR` --- регистр инструкций (Instruction Register), предназначен для хранения активной команды или операционного кода, поступающего из памяти команд.
    - `AR` --- регистр адреса операнда (Address Register) содержит адрес памяти, который будет использован в следующих тактах.
    - `C` --- флаг переноса/заёма
    - `Z` --- флаг нуля
- Команды выполняются за 2 или 3 такта (в зависимости от типа команды):
    1. Выборка команды
    2. Выборка операндов
    3. Выполнение команды.
- Подсистема обработки прерываний и команды вызова подпрограмм отсутствует.
- В архитектуре предусмотрен мультиплексор (MUX2), который позволяет выбирать источник данных для левого входа арифметико-логического устройства (АЛУ): либо данные из памяти данных, либо данные из памяти команд. Второй аргумент для АЛУ поступает исключительно из аккумулятора, в который затем записывается результат вычислений.

[Пример модели процессора на Haskell](http://amazing-new-gate.blogspot.com/2010/07/haskell.html)

### Пример исполнения архитектуры

```
add #01 <- 34 + #03
; I <opcode>, 34, 03, 01 ] 5t
асс <- 34      ; 1 <opcode>, 34 ] 2t
асс <-  #03.   ; [ <opcode>, 03 ] 3t
#01 <- Acc     ; [ ‹opcode>, 01 ] 3t

; --- 1. Чтение инструкции

IR <- PMem[ PC]
PC <- PC+1

; --- 2. Инициализация акк. 34

{ Acc, Z, C } <- ALU( ... )
             <-  MUX2( ... )
             <- PMem [PC]
PC + PC+1

; --- 3. Выгрузка адреса 03

AR <- PMem[ PC]
PC <- PC+1

; --- 4. Выгрузка адреса 01 
; ---     Выгрузка #03 и сложение

AR <- PMem[PC]
{ Acc, Z, C } <- ALU( ... )
              <- MUX2 ( ... ) 
              <- DMem[AR].DOUT
PC <- PC+1

; --- 5. Сохранение результата

DMem[AR].DIN <- Acc
```

Конечно! Я всё понял. Ты дал объёмную, но очень хаотичную стену текста. Я сейчас структурирую весь материал для методички: аккуратно разобью его на логические части, сделаю форматирование для `.md` (Markdown) файла — заголовки, списки, выделение важного — и сделаю так, чтобы его было удобно читать и понимать.

Вот первая версия красиво оформленного файла:

---

# Выполнение инструкции `ADD #01 <- 34 + #03`

## Описание операции

**Инструкция:**
```assembly
ADD #01 <- 34 + #03
```
Расшифровка:
- Взять значение константы `34`
- Взять значение по адресу `#03`
- Сложить их
- Сохранить результат по адресу `#01`

**Кодировка инструкции в памяти:**
```assembly
; I <opcode>, 34, 03, 01 ] 5 тактов
```
Инструкция занимает **4 байта**:
- 1 байт — `opcode`
- 3 байта — аргументы (`34`, `03`, `01`)

---

## Пошаговое выполнение инструкции

### 1. Чтение инструкции

```assembly
IR <- PMem[PC]
PC <- PC + 1
```
- **IR** (Instruction Register) загружает инструкцию из памяти команд (PMem) по адресу **PC**.
- **PC** инкрементируется, чтобы указывать на следующий байт (аргумент инструкции).

---

### 2. Инициализация аккумулятора значением 34

```assembly
{Acc, Z, C} <- ALU(...)
              <- MUX2(...)
              <- PMem[PC]
PC <- PC + 1
```
- Значение `34` считывается из PMem и через мультиплексор (MUX2) загружается в аккумулятор (Acc).
- Выполняется инкремент Program Counter (PC).

---

### 3. Загрузка адреса операнда #03

```assembly
AR <- PMem[PC]
PC <- PC + 1
```
- Значение `03` считывается из PMem и загружается в адресный регистр (AR).

---

### 4. Загрузка адреса результата #01 и выполнение сложения

```assembly
AR <- PMem[PC]
{Acc, Z, C} <- ALU(...)
              <- MUX2(...)
              <- DMem[AR].DOUT
PC <- PC + 1
```
- Считывается адрес `01`.
- Производится сложение: значение из аккумулятора (`34`) и значение из памяти данных по адресу `03`.

---

### 5. Сохранение результата

```assembly
DMem[AR].DIN <- Acc
```
- Результат сложения записывается в память данных по адресу `01`.

---

## Важные замечания

- **Почему 4 байта на инструкцию?**
  - Чтобы упростить работу процессора: один байт на `opcode` и три байта на аргументы.

- **Сравнение с аккумуляторной архитектурой:**
  - В классической аккумуляторной архитектуре понадобилось бы 3 инструкции:
    1. Загрузить константу в аккумулятор
    2. Загрузить значение из памяти в аккумулятор
    3. Сохранить аккумулятор в память
  - Это приводит к увеличению объёма кода и большему количеству тактов (8 тактов против 5).

- **Эффективность:**
  - Вариант с четырьмя байтами эффективнее как по скорости выполнения, так и по объёму памяти.

---

# Вычислительный процесс в процессоре

## Общая логика работы

1. **Program Counter (PC)** указывает на текущую инструкцию в памяти команд.
2. **IR** защёлкивает считанную инструкцию.
3. **PC** сразу инкрементируется, чтобы готовиться к чтению следующего байта (аргумента).
4. **Чтение аргументов** происходит в последующие такты:
    - Первый аргумент идёт в аккумулятор.
    - Второй аргумент в адресный регистр (AR).
    - Третий аргумент снова в AR (для записи результата).

---

## Особенности работы сигналов

- Данные на шинах могут меняться, но защёлкивание в регистры происходит только при наличии управляющего сигнала.
- Важно правильное управление временем считывания и защёлкивания данных, чтобы избежать конфликтов.

---

## Частые вопросы

### Почему в третьем и четвёртом пунктах снова считываются данные в AR?

- Всё правильно: сначала читается адрес операнда `#03`, затем адрес результата `#01`.
- Процессы чтения и выполнения в цифровых схемах **идут параллельно**, а не строго последовательно.

---

## Вывод

- Система команд, основанная на прямой работе с аргументами, даёт **меньший объём кода** и **меньшее количество тактов** на выполнение операций.
- В отличие от аккумуляторной архитектуры, где требуется больше инструкций.
- Таким образом, переход к более сложной системе команд даёт выигрыш в производительности и экономии памяти.
- Это направление развития вычислительной техники привело к архитектуре типа **CISC (Complex Instruction Set Computer)**.

---

# Почему важно инкрементировать PC в каждом такте?

- Чтобы не потерять последовательность аргументов в памяти команд.
- Следующий аргумент инструкции должен быть доступен к моменту следующего такта без дополнительного ожидания.
- Это позволяет параллелить процессы: чтение следующего байта и выполнение текущего.

## Complex Instruction Set Computer

**Complex Instruction Set Computing (CISC)** --- архитектура процессора с полным набором команд, в которой отдельные инструкции способны выполнять несколько операций низкого уровня (например, загрузку из памяти, арифметические вычисления и сохранение обратно в память) или многошаговые процедуры в рамках одной инструкции. Основоположником CISC-архитектуры считается компания IBM с архитектурой IBM/360. Типичными примерами CISC-процессоров являются x86, Motorola MC680x0, Zilog Z80 и мейнфреймы серии zSeries.

Основная идея CISC заключалась в стремлении обеспечить максимально эффективное управление процессором. Для этого систему команд усложнили, чтобы минимизировать количество лишних операций при выполнении задач. Архитектура стремилась к тому, чтобы каждая типовая операция обработки данных имела свою специализированную машинную команду. Это позволило упростить процесс программирования на низкоуровневых языках и существенно сократить объем разрабатываемого кода.

Одним из факторов, способствовавших развитию CISC, стало внедрение микропрограммного управления. Микропрограммы позволяли сравнительно просто формировать сложные команды и расширенные режимы адресации без значительных затрат на аппаратную реализацию. Благодаря этому стало возможным:
- поддерживать различные режимы адресации для всех типов команд;
- реализовывать сложные арифметические операции в рамках одной инструкции;
- создавать потоковые операции обработки данных.

Микропрограммное управление также обеспечивало возможность обновления и оптимизации работы процессора после его выпуска за счёт изменения микрокода, как это было реализовано, например, в системах семейства УВК «Самсон» для РВСН.


**Причины появления архитектуры CISC**
- **Низкоуровневые языки:** На момент появления CISC-процессоров высокоуровневые языки ещё не получили широкого распространения. Программирование велось преимущественно на ассемблере, и наличие расширенного набора команд облегчало написание кода.
- **Разнообразие архитектур:** Существенные различия между архитектурами затрудняли переносимость программ. Универсальные и мощные команды помогали нивелировать эти различия.
- **Неразвитость компиляторов:** Ограниченные возможности компиляторов вынуждали перекладывать задачи оптимизации программ на процессоры с расширенным набором инструкций.
- **Удобство программирования:** Большое количество мощных команд позволяло уменьшить объём кода и упростить его разработку.
- **Высокая производительность:** Многофункциональные инструкции обеспечивали выполнение сложных операций за один цикл программной логики, повышая эффективность без дополнительных оптимизаций.
- **Минимизация объёма программ:** Компактные инструкции позволяли экономить дефицитные ресурсы памяти.
- **Минимизация накладных расходов:** Уменьшение количества обращений к памяти и внутренних пересылок данных снижало накладные затраты при выполнении программ.


**Преимущества архитектуры CISC**
- Удобство использования ассемблера для написания программ.
- Снижение затрат на доступ к памяти команд благодаря более коротким программам.
- Возможность обновления микрокода для улучшения функциональности процессора.
- Возможность оптимизации микрокода для конкретных алгоритмов, сокращение объема программ и устранение лишних операций.


**Проблемы архитектуры CISC**
- **Сложность системы команд:** Большое количество команд делает их полное освоение и эффективное использование сложной задачей для программистов и компиляторов.
- **Усложнение устройства процессора и блока управления:** Наличие множества инструкций, способов адресации и аргументов приводит к значительному усложнению схем управления процессором.
- **Сложность генерации эффективного машинного кода:** Автоматические компиляторы испытывают трудности в создании оптимального кода для CISC-процессоров.
- **Высокая стоимость хранения микрокода:** Микропрограммы требуют размещения в быстрой внутренней памяти процессора, что увеличивает стоимость чипа.
- **Повышенные требования к разработчикам:** Разработка и сопровождение сложных систем команд требуют глубоких знаний архитектуры процессора.
- **Сложности оптимизации производительности:** Большое разнообразие команд и их неоднородность затрудняют реализацию высокоэффективных методов обработки, таких как конвейеризация и суперскалярность.
- **Высокая стоимость разработки микрокода:** Программирование микрокода требует значительных затрат на отладку и оптимизацию.

Несмотря на выявленные недостатки, архитектура CISC продолжает активно использоваться ведущими производителями процессоров (Intel, AMD, IBM). В современных CISC-процессорах применяются гибридные подходы, сочетающие принципы CISC и RISC для достижения максимальной производительности.

![CISC](fig/cisc.png){ width=50% }

**Пример системы команд и линейной функции Y = A * X + B:**

```
load R1 <- A          ; reg-to-reg
load R2 <- X          ; 3 operands
load R3 <- B
lnf R4 < -R1 * R2 + R3
store Y <- R4         ;          

```

Здесь применена сложная инструкция, которая сразу вычисляет линейную функцию в рамках одной команды.

Такой подход характерен для специализированных процессоров, где известно, что необходимо выполнять множество однотипных линейных функций. Реализация подобных операций на уровне аппаратуры процессора даёт ряд преимуществ:

 + Несмотря на увеличение набора инструкций, каждую такую операцию можно оптимизировать на уровне микрокода или схемотехники для максимально быстрого исполнения.

 + Минимизируется количество обращений к памяти и регистрам: все необходимые данные загружаются заранее, после чего выполняется сразу полное вычисление.

 + Уменьшается общий объём машинного кода за счёт высокой плотности операций.

 + Снижается нагрузка на шину данных, так как не требуется дополнительной загрузки промежуточных результатов.

В результате получается максимально компактный и быстрый код, что особенно важно в задачах с большим числом однотипных вычислений.

## Microcode

При проектировании CISC-процессоров приоритетным направлением является разработка устройства процессора и блока управления (Control Unit), поскольку реализация конечного автомата, способного поддерживать сложную систему команд, представляет собой исключительно сложную задачу с аппаратной точки зрения.

Существует два основных подхода к реализации Control Unit:

- **Hardwired (жёстко заданный)** --- управление реализуется через комбинационные схемы, декодирующие инструкции в последовательности управляющих сигналов. Блок управления использует фиксированный набор логических вентилей и схем, при этом каждая инструкция имеет заранее заданную жёсткую реализацию. Hardwired-блоки просты и быстры, однако они малогибки и трудны для модификации.

- **Microcoded (микропрограммный)** --- управление осуществляется посредством исполнения микропрограммы, управляющей выполнением инструкций. Внутри процессора размещается очень быстрая память, в которой хранится микрокод, управляющий всеми процессами на уровне выполнения инструкций.

**Микрокод** — это программа, реализующая набор инструкций процессора. Подобно тому, как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в микрокодируемом процессоре каждая машинная инструкция превращается в последовательность микроинструкций. Микрокод служит промежуточным уровнем между аппаратной реализацией процессора и видимой программисту архитектурой набора инструкций.

Микрокод хранится в памяти только для чтения (**ROM**), которая значительно дешевле оперативной памяти. Это позволяет выгодно использовать постоянную память, снижая потребность в более дорогих компонентах.

Размещённый в специализированной высокоскоростной памяти, микрокод преобразует машинные инструкции или другие входные данные в последовательности детализированных низкоуровневых операций. Микрокод позволяет отделить реализацию инструкций от базовой электроники, обеспечивая гибкость в проектировании и возможностях модификации. Он также упрощает реализацию сложных многошаговых инструкций, одновременно снижая общую сложность аппаратуры.

Процесс написания микрокода называют микропрограммированием. В конкретной реализации процессора микрокод часто называют микропрограммой. Основная идея микрокода заключается в замене специализированной аппаратной логики серией простых микроинструкций, выполняемых движком микрокода. В этом движке каждая микроинструкция последовательно активирует необходимые управляющие сигналы. Микрокод может быть битово закодирован, где каждый бит отвечает за определённую управляющую линию, аналогично тому, как отверстия на перфорированном рулоне механического пианино управляют звучанием клавиш.

Первые процессоры могли быть реализованы полностью аппаратно, а основным языком программирования был ассемблер, напрямую соответствующий системе команд процессора. Разработчики стремились одновременно к высокой производительности и удобству программирования.

Попытки повысить удобство через введение дополнительных абстракций приводили к:

- высоким накладным расходам (например, через активное использование подпрограмм);
- раздуванию исходного кода (например, при широком использовании inline-функций).

Одним из путей улучшения пользовательского опыта стало расширение набора инструкций, позволяющее естественно и без дополнительных накладных расходов реализовывать частые операции. Это расширение включало:

- добавление команд с увеличенным числом аргументов;
- команды для непосредственной работы с памятью без обязательного сохранения результата в регистр.

Как следствие, расширение набора команд не требовало радикальных изменений в архитектуре процессора (таких как новые шины данных или регистры), а лишь специфического использования уже существующих аппаратных ресурсов.

![Микрокод]( fig/microcode-decode.png )

Инструкции прибывают из памяти, обычно из высокоскоростного кеша. Далее они входят в декодер, который разбивает каждую инструкцию на одну или несколько микроопераций. Хотя они выполняют меньше одной инструкции, они значительно больше.
Следствие --- необходимость "программирования" системы команд процессоров, что вылилось в понятие микрокода --- программы, реализующей набор инструкций процессора. К примеру (Wikipedia):

+ Подсоединить регистр 1 ко входу A АЛУ;
+ Подсоединить регистр 7 ко входу B АЛУ;
+ Настроить АЛУ на выполнение операции сложения;
+ Установить разряд переноса АЛУ в ноль;
+ Сохранить результат операции в регистр 8;
+ Обновить коды состояния из флагов АЛУ («Отрицательное», «Ноль», «Переполнение», «Перенос»);
+ Установить указатель микрокоманд на микроинструкцию номер nnn.

Первоначально микрокод был использован в качестве более простого способа разработки управляющего устройства процессора. Прежде набор инструкций задавался жёстко, каждая машинная инструкция (сложение, сдвиг, копирование) реализовывалась непосредственно в схеме. Это давало высокую скорость, но по мере того, как набор инструкций рос, всё сложнее становилось реализовывать в виде схемы и отлаживать инструкции всё возрастающей сложности. Микрокод смягчил эту проблему тем, что позволил инженерам-проектировщикам при реализации сложной инструкции заменить создание сложной схемы на написание микропрограммы. Более того, микрокод можно было с лёгкостью изменить на поздних этапах проектирования, схему же изменить намного сложнее. Таким образом, микрокод облегчил проектирование процессоров, что привело к усложнению набора команд.

Примечания:

+ Как продать свой процессор? Нужно показать классный код на ассемблере.
+ Xerox Alto - один из знаковых компьютеров, предоставляющий программисту уровень микропрограммирования. Тот самый компьютер от Xerox [wiki](https://en.wikipedia.org/wiki/Xerox_Alto), [Alto: A personal computer](http://people.scs.carleton.ca/~soma/distos/fall2008/alto.pdf).

## No Instruction Set Computing

**No instruction set computing (NISC)** --- это вычислительная архитектура и технология компиляции для проектирования высокоэффективных специализированных процессоров и аппаратных ускорителей, позволяющая компилятору осуществлять низкоуровневый контроль над аппаратными ресурсами. NISC (No Instruction Set Computer) не использует заранее определённый набор команд или микрокод. Компилятор генерирует нанокоды для непосредственного управления набором команд или микрокодом.

Если мы посмотрим на процессор и зададимся вопросом: "А зачем нам вообще нужны инструкции?", становится очевидным, что процессор в реальности управляется микроинструкциями. Тогда возникает идея: отказаться от этапа компиляции в машинные инструкции и вместо этого компилятору сразу выдавать трассы микроинструкций, которые напрямую загоняются в процессор для управления.

В классическом CISC-процессоре (схема предоставлена в соответсвующем разделе) мы видим:
- Program Counter
- Program Memory
- Micro Program Counter
- Micro Program Memory
- Управляющие слова

Если удалить этап с Micro Program Counter и Micro Program Memory, останется только Program Counter и Program Memory. Это позволяет значительно упростить процессор. Теперь компилятор, понимая что именно он делает, может сразу генерировать оптимальный для конкретной аппаратуры код.

![NISC](fig/nisc.png){ width=50% }

Преимущества такого подхода:
- Значительное упрощение аппаратной части.
- Максимальная эффективность программного управления.
- Отсутствие необходимости в проектировании и поддержке ISA (Instruction Set Architecture), так как управляющие сигналы напрямую задаются железом.
- ISA в таком подходе становится фактически уровнем абстракции, который обеспечивает контроль за процессором на уровне микрокода. Это позволяет сократить количество типов команд (хотя общий объём программы может увеличиваться за счёт количества управляющих сигналов) и снижает накладные расходы на выполнение инструкций.
- Упрощение разработки процессоров: устраняется сложный и трудоёмкий этап проектирования ISA, что особенно важно для специализированного оборудования. Однако одновременно исчезает бинарная совместимость между различными процессорами — что, впрочем, некритично для систем-на-кристалле и узкоспециализированных решений.
- Упрощение структуры процессора: оставляются только элементы, необходимые для выполнения вычислений, а всё возможное переносится на уровень компилятора.
- Благодаря простой структуре процессора становится возможным его сравнительно лёгкая адаптация под конкретные задачи, особенно в системах на ПЛИС (FPGA), что обусловливает применение данной архитектуры в рамках [высокоуровневого синтеза](https://www.youtube.com/watch?v=mbheV9V8AbM) ([слайды](https://drive.google.com/file/d/161Lj0fVLHgSYLQMaz0Sn_3TaYUGWYvNI/view)).

Однако у такого подхода есть и очевидные недостатки:
1. **Невозможность бинарной совместимости.** Для исполнения кода на другом процессоре потребуется полное совпадение их внутреннего устройства. Отсутствие разделения между архитектурой процессора и его микроархитектурой приводит к тому, что компилятор, программист и процессор должны разрабатываться совместно и не могут развиваться независимо.
2. **Низкая плотность машинного кода.** Управляющие слова содержат большое количество "пустых" нулей. Память внутри процессора оказывается перегруженной хранением лишних данных, и эти нули приходится передавать по шинам, что увеличивает накладные расходы.

На практике для борьбы с низкой плотностью кода иногда применяются аппаратные архиваторы, которые позволяют хранить программу в сжатом виде и распаковывать её на лету. Несмотря на это, подобный подход остаётся экзотическим и применяется в основном в специфических задачах, где процессоры проектируются под конкретное применение.

Есть две основных области применения таких идей:
- **Высокоуровневый синтез (HLS, High-Level Synthesis).** Это специальные САПР-инструменты, которые позволяют на основе программы на языке C автоматически сгенерировать цифровую схему, реализующую алгоритм. Такой подход значительно упрощает проектирование цифровой обработки сигналов и других специализированных вычислений, хотя инструменты HLS остаются сложными в использовании. Под капотом они часто используют низкоуровневую архитектуру: микропрограммное управление плюс датапас, где микропрограмма координирует действия датапаса в зависимости от скомпилированного алгоритма.
- **CGRA-процессоры (Coarse-Grained Reconfigurable Architectures).** Эти архитектуры потенциально представляют будущее вычислительной техники. Мы коснёмся этой темы ближе к концу семестра, в рамках проекта по разработке САПРов для спецпроцессоров.

## Ссылки

[Instruction Set Architecture](https://edizsaykol.weebly.com/uploads/9/8/6/5/9865252/lecture_02_architecture_overview.pdf)

[Microcode](https://en.wikipedia.org/wiki/Microcode#Microcode)

[Архитектура Фон-Неймана, курс лекций "Архитектура ЭВМ и язык Ассемблера" факультета Вычислительной математики и кибернетики Московского Государственного университета им. М. В. Ломоносова](http://arch32.cs.msu.su/Text/Chapter_02.pdf)

[CISC](https://web.archive.org/web/20180925234153/http://www.nsc.ru/win/elbib/data/show_page.dhtml?77+739)


