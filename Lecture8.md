# [Конспект лекции №8](https://www.youtube.com/watch?v=Iko9CJl2MwQ)

## ISA Overview

Как вы можете представить, количество инструкций, которые понимает процессор, ограничено. Если вы знакомы с программированием, вы знаете, что можно определять собственные функции. Так вот, машинные команды не имеют такой возможности.

Существует фиксированное количество команд, которые понимает процессор. И вы как программист не можете его расширить.

В мире представлено множество различных микропроцессоров, и они не используют одинаковый набор команд. Иными словами, они интерпретируют числа в инструкции по-разному.

Одна архитектура микропроцессора трактует число 501012 как add r10, r12, а другая архитектура — как load r10, 12. Комбинация инструкций, которые понимает процессор, и регистров, которые ему доступны, называется архитектурой набора команды (Instruction Set Architecture, ISA).

Instruction Set Architecture (ISA) — это набор команд микропроцессора и система правил, по которым эти команды интерпретируются и выполняются. В общем смысле, ISA служит интерфейсом между аппаратурой компьютера и программным обеспечением.

ISA определяет доступные команды процессора, их формат, регистры, типы данных, режимы адресации, а также способы управления потоками данных и выполнением команд.

Система команд процессора: (Instruction Set Architecture -- ISA) абстрактная модель процессора, формирующая интерфейс взаимодействия между программным обеспечением и процессором.
Производительность, энергопотребление и задержки часто не рассматриваются.

Машинное слово: фрагмент данных фиксированного размера, обрабатываемый как единое целое процессором.
- типы данных,
- модель памяти, система и методы адресации,
- набор инструкций,
- механизмы обработки прерываний и исключений,
- методы ввода и вывода.

![image](https://github.com/user-attachments/assets/c0f296af-4207-4a55-a6b1-bf187fa0c935)
![image](https://gitlab.se.ifmo.ru/computer-systems/csa-rolling/-/raw/master/fig/isa-as-interface.png)


### Аккумуляторная архитектура

Аккумуляторная архитектура возникла одной из первых, потому очень проста. В ней для хранения одного из операндов арифметической или логической операции в процессоре имеется выделенный регистр — аккумулятор. В этот же регистр заносится и результат операции. Изначально оба операнда хранятся в основной памяти,и до выполнения операции один из них нужно загрузить в аккумулятор. После выполнения команды обработки результат находится в аккумуляторе и, если он не является операндом для последующей команды, его требуется сохранить в ячейке памяти.

![image](https://github.com/user-attachments/assets/3b4bf477-2050-4816-adf1-e7e12b9750e3)

### Регистровая архитектура

Данная архитектура является логическим продолжением аккумуляторной и особо не отличается, заисключением того, что теперь заместо одного аккумулятора у нас будет много регистров.

Микропроцессор с архитектурой данного типа включает в себя массив регистров, известных как регистры общего назначения. В микропроцессоре отсутствует специальный регистр данных, выполняющий функции аккумулятора. Функции аккумулятора выполняет один из регистров общего назначения.

Размер регистров обычно фиксирован и совпадает с размером машинного слова.К любому регистру можно обратиться,указав его номер. Регистровая архитектура допускает расположение операндов в одном из двух пространств: основной памяти или регистрах. С учетом возможного размещения операндов в рамках регистровых архитектур выделяют три типа команд обработки: Register-to-Register, Register-to-Memory, Memory-to-Memory.

| Тип | Достоинства | Недостатки |
|----------|----------|----------|
| Register-to-Memory    | Данные могут быть доступны без загрузки в регистры процессора; простота кодирования команд; объектный код получается достаточно компактным   | Потеря одного из операндов при записи результата; длинное поле адреса памяти в коде команды сокращает место под номер регистра, что ограничивает общее число РОН. Количество тактов процессора, приходящихся на одну команду (CPI), зависит от места размещения операнда   |
| Register-to-Register    | Простота реализации; фиксиро­ванная длина команд; простая модель формирования объект­ного кода при компиляции программ; возможность выполне­ния всех команд за одинаковое количество тактов   | Большая длина объектного кода; из-за фиксированной длины команд часть разрядов в коротких командах не используется   |
| Memory-to-Memory    | Компактность объектного кода, малая потребность в регистрах для хранения промежуточных данных   | Разнообразие форматов команд и времени их исполнения, низкое быстродействие из-за обращения к памяти   |

#### Register-to-Memory

В архитектуре Register-to-Memory один из операндов для операций, таких как сложение (ADD), может находиться в памяти, в то время как другой — в регистре.

![image](https://github.com/user-attachments/assets/b8bddab3-d0bc-420d-a86d-b8c306bf171e)
#### Register-to-Register
![image](https://github.com/user-attachments/assets/3a0a9c2f-3f3a-40a9-aa31-ae3f3586ed6b)
#### Memory-to-Memory
![image](https://github.com/user-attachments/assets/558199b1-316e-4727-aad2-ca919c05520a)
### Стековая архитектура

Отдельно от других типов архитектур выделяется стековая архитектура. В её основе лежит принцип использования стековой памяти, размещённой непосредственно внутри процессора, вместо традиционного набора регистров. Стек представляет собой совокупность связанных между собой ячеек памяти, функционирующих по принципу «последним вошёл — первым вышел» (LIFO, Last In First Out), что позволяет обращаться исключительно к элементу, находящемуся на вершине стека. Соответственно, в стековой архитектуре аргументы явно не указываются, а используются данные, размещённые на вершине стека.

**Преимущества стековой архитектуры**:
1. **Естественная поддержка процедур**. Аргументы функций передаются посредством стека без необходимости использования ограниченного числа регистров, что особенно актуально при глубокой вложенности вызовов. Это избавляет от необходимости введения соглашений об использовании регистров — все необходимые данные просто помещаются в стек.
2. **Простота реализации**. Стековая архитектура характеризуется простотой реализации и минималистичным машинным кодом, что упрощает проектирование процессоров.

**Недостатки стековой архитектуры**:
1. **Неудобство произвольного доступа**. В случае необходимости обращения к элементам стека, расположенным не на вершине, возникает необходимость выполнения дополнительных операций, что приводит к увеличению количества команд. Для частичного решения этой проблемы могут использоваться несколько стеков или дополнительные регистры.
2. **Сложности в оптимизации**. Ограничение работы только с вершиной стека затрудняет распараллеливание операций, что снижает производительность и ограничивает возможности ускорения выполнения программ.

Стековые процессоры часто применяются в реализации интерпретаторов, поскольку построение виртуальных машин на основе стека является удобным и эффективным решением.

![image](https://github.com/user-attachments/assets/43be07b5-7655-40ab-aba3-b935a9dea4d2)

## Машина фон-Неймана

Машина фон Неймана представляет собой абстрактную модель вычислительной системы, поскольку многие элементы её архитектуры изначально не были конкретизированы. Это сделано намеренно, чтобы не ограничивать творческий подход инженеров-разработчиков при создании новых ЭВМ. Таким образом, архитектура машины фон Неймана описана не на уровне внутренней реализации, а на концептуальном уровне представления вычислительного процесса.

Рассмотрим более конкретную организацию архитектуры фон Неймана:

![image](https://gitlab.se.ifmo.ru/computer-systems/csa-rolling/-/raw/master/fig/von-neumann-example.png)

Описание:

- Разрядность процессора: 8 бит.
- Организация памяти: гарвардская, с отдельными блоками памяти для команд и данных.
- Внешние устройства (для данной работы это светодиоды, двухпозиционные переключатели и тактовые кнопки) отображаются в адресное пространство данных. Работа с ними выполняется по опросу.
- Регистры:
    - `PC` --- регистр счётчика команд (Program Counter) указывает адрес текущей инструкции, при этом общее количество возможных инструкций составляет 256.
    - `IR` --- регистр инструкций (Instruction Register), предназначен для хранения активной команды или операционного кода, поступающего из памяти команд.
    - `AR` --- регистр адреса операнда (Address Register) содержит адрес памяти, который будет использован в следующих тактах.
    - `C` --- флаг переноса/заёма
    - `Z` --- флаг нуля
- Команды выполняются за 2 или 3 такта (в зависимости от типа команды):
    1. Выборка команды
    2. Выборка операндов
    3. Выполнение команды.
- Подсистема обработки прерываний и команды вызова подпрограмм отсутствует.
- В архитектуре предусмотрен мультиплексор (MUX2), который позволяет выбирать источник данных для левого входа арифметико-логического устройства (АЛУ): либо данные из памяти данных, либо данные из памяти команд. Второй аргумент для АЛУ поступает исключительно из аккумулятора, в который затем записывается результат вычислений.

[Пример модели процессора на Haskell](http://amazing-new-gate.blogspot.com/2010/07/haskell.html)

## Complex Instruction Set Computer

Основная идея заключалась в стремлении обеспечить максимально эффективное управление процессором. Для этого систему команд усложнили таким образом, чтобы при выполнении задач процессор выполнял минимальное количество лишних операций. Именно на этой основе и сформировалась архитектура CISC-процессоров.

**CISC** - это компьютерная архитектура, в которой отдельные инструкции могут выполнять несколько операций низкого уровня (загрузка из памяти, арифметическая операция и сохранение в памяти) или способны выполнять многошаговые операции или режимы адресации в рамках отдельных инструкций.

**Причины появления:**
- **Низкоуровневые языки**: В период появления CISC-процессоров высокоуровневые языки программирования были слабо развиты или отсутствовали. Работа велась преимущественно на ассемблере, и наличие расширенного набора инструкций облегчало процесс программирования.
- **Разнообразие архитектур**: Существовало множество несовместимых между собой архитектур, что затрудняло переносимость и разработку программ. Универсальные и многофункциональные команды позволяли частично сгладить различия между платформами.
- **Неразвитость компиляторов**: Компиляторы того времени были недостаточно эффективными в оптимизации программного кода. Для повышения производительности и упрощения разработки часть задач перекладывалась непосредственно на процессор через расширенные инструкции.
- **Удобство программирования**: Наличие большого количества сложных инструкций позволяло уменьшить объём кода и упростить процесс его написания.
- **Высокая производительность**: Многофункциональные инструкции позволяли за одну операцию выполнять сложные задачи. Это обеспечивало рост производительности при выполнении программ без необходимости сложных программных оптимизаций.
- **Минимизация объёма программ**: Использование ёмких по функционалу инструкций уменьшало общий объём программного кода, что было критически важно в условиях ограниченных ресурсов памяти.
- **Минимизация накладных расходов**: Сложные инструкции позволяли сократить количество обращений к памяти и внутренних операций. Это уменьшало накладные расходы при выполнении программ и повышало общую эффективность вычислений.

**Проблемы:**
- **Сложная система команд (использование, анализ)**. Увеличение количества команд приводит к тому, что программисты затрудняются в полном объёме освоить и эффективно применять предоставленные процессором возможности. Аналогично, компиляторы сталкиваются с трудностями при генерации кода, не используя весь доступный набор инструкций.
- **Сложное устройство процессора и Control Unit**. Рост числа инструкций, способов адресации и вариантов работы с аргументами приводит к усложнению алгоритмов управления процессором, что, в свою очередь, увеличивает сложность его внутренней организации. 
- **Сложно генерировать эффективный машинный код**. Повышенная сложность архитектуры затрудняет создание оптимального машинного кода как вручную, так и средствами автоматизированных компиляторов.

Методика построения системы команд CISC противостоит методике, применяемой в другом распространённом типе процессорных архитектур — RISC, где используется набор упрощённых инструкций. Типичными представителями CISC-архитектуры являются процессоры на основе команд x86, процессоры Motorola MC680x0, Zilog Z80, процессоры мейнфреймов zSeries.

Архитектура CISC в значительной степени стала возможна благодаря возможностям микропрограммного управления. Микропрограмма позволяет относительно легко (по сравнению с разработкой аппаратуры) формировать большое количество команд со сложным поведением. Поднять уровень машинных инструкций ближе к уровню языков программирования высокого уровня. К примеру:

+ относительно легко поддержать все интересующие варианты адресаций для всех типов команд;
+ реализовать операции с произвольным набором аргументов, к примеру, инструкцию для расчета многочленов в рамках одной инструкции;
+ реализовать операции, работающие в потоковом режиме.

Основными преимуществами такого подхода являются:

+ удобство использования ассемблера как инструмента программирования;
+ сокращение затрат на доступ к памяти команд, так как гибкость позволяет сократить количество инструкций;
+ возможность обновления микропрограммного управления позволяет обновить "прошивку" процессора, и тем самым улучшить его функциональность уже после производства аппаратуры;
  + Существуют семейства процессоров и инструментальных средств для них, активно эксплуатирующие данную возможность, к примеру: УВК «Самсон» – базовая ЭВМ РВСН. Оптимизация микрокода под конкретный алгоритм позволяет сократить объём программ (машинное представление), а также оптимизировать лишние операции.

Но также он сопряжён с рядом недостатков:

+ Необходимо хранить микрокод непосредственно в процессоре (необходим мгновенный доступ к нему), где хранение данных --- весьма дорогой процесс, по сравнению с внешней памятью. Чем сложнее система команд, тем больше необходимо памяти.
+ Развитый ассемблер требует большого объёма знаний о процессоре от разработчика. Кроме того, лёгкость развития и модернизации системы команд провоцирует рост разнообразия процессорных архитектур, что, в свою очередь, накладывает серьёзные требования на инструментальные средства.
+ Наличие большого количества программного обеспечения (пусть и в виде микрокода) сопряжено со всеми сложностями программирования. В данном случае это означает, что программное обеспечение нуждается в дорогостоящей отладке и оптимизации, что значительно повышает стоимость разработки.
+ Большое разнообразие команд делает их относительно уникальными с точки зрения формата, размера команды, длительности исполнения и количества доступов к памяти. Как следствие это усложняет:

  + реализацию оптимизаций в рамках процессора (конвейерное исполнение, суперскалярность и т.п.);
  + поддержку со стороны инструментальных средств (компиляторы, дизассемблеры, отладчики и т.п.), в качестве примера можно посмотреть о сложностях разработки дизассемблеров для современных процессоров x86.

Примечание: CISC процессор необязательно нуждается в микрокоде, но, как правило, подразумевает его наличие.

![image](https://github.com/user-attachments/assets/dfef9295-5e10-4c20-bb4e-d61195965884)

## Microcode

Что нам стоит ставить на первое место в проектировании CISC процессоров, понятное дело, что с точки зрения аппаратуры и и того, как оно работает под капотом? Это второй пункт: устройство Control Unit, потому что сделать в аппаратуре конечный автомат, который будет генерировать все это многообразие инструкций невероятно сложно. 

Eсть два подхода к реализации Control Unit:
- **Hardwired**. При помощи аппаратных комбинационных схем, декодирующих инструкции в последовательности сигналов. Этот блок управления использует фиксированный набор логических вентилей и схем для выполнения инструкций. Управляющие сигналы для каждой инструкции жестко подключены к блоку управления, поэтому блок управления имеет специальную схему для каждой возможной инструкции. Hardwired control units просты и быстры, но они могут быть негибкими и сложными для модификации.
- **Microcoded**. При помощи исполнения микропрограммы, реализующей необходимые функции. Это значит, что внутри процессора будет лежать память, которая должна быть очень быстрой, ведь мы будем обращаться к ней очень много раз в течение каждой инструкции, и которая будет управлять всем алгоритмом внутри процессора.

**Микропрограмма** (микрокод) - программа, реализующая набор инструкций процессора. Так же как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в процессоре, использующем микрокод, каждая машинная инструкция реализуется в виде серии микроинструкций — микропрограммы, микрокода.


Микроко́д — программа, реализующая набор инструкций процессора. Так же, как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в процессоре, использующем микрокод, каждая машинная инструкция реализуется в виде серии микроинструкций — микропрограммы, микрокода. В проектировании процессоров микрокод служит промежуточным слоем, расположенным между аппаратным обеспечением центрального процессора (CPU) и видимой программисту архитектурой набора инструкций компьютера, также известной как машинный код.

Микрокод хранится в ROM-памяти (Read-Only Memory, только для чтения), которая значительно дешевле оперативной памяти. Следовательно, уменьшение использования оперативной памяти через увеличение использования постоянной памяти — выгодный компромисс.

Микрокод, размещённый в специальной высокоскоростной памяти, преобразует машинные инструкции, данные конечных автоматов или другие входные данные в последовательности детализированных операций на уровне схем. Он отделяет машинные инструкции от базовой электроники, обеспечивая тем самым большую гибкость в проектировании и изменении инструкций. Кроме того, микрокод облегчает реализацию сложных многошаговых инструкций, одновременно снижая сложность компьютерных схем. Процесс написания микрокода часто называют микропрограммированием, а сам микрокод в конкретной реализации процессора иногда называют микропрограммой.

Основная идея микрокода заключается в замене специализированной аппаратной логики, реализующей последовательность выполнения инструкций, серией простых инструкций, выполняемых в так называемом "движке микрокода", встроенном в процессор. В то время как специализированная логическая система может состоять из диодов и логических элементов, подающих определённые напряжения на различные управляющие линии, движок микрокода подключается к этим линиям и включает или отключает их по мере последовательного чтения инструкций микрокода. Инструкции микрокода часто кодируются по битам в соответствии с этими линиями: например, если бит 8 установлен в единицу, это может означать, что арифметико-логическое устройство (ALU) должно приостановиться в ожидании данных. В этом смысле микрокод чем-то напоминает перфорированные рулоны в механическом пианино, где отверстия обозначают, какую клавишу следует нажать.

Первые процессоры могли быть реализованы полностью на аппаратном уровне. Основным инструментом программирования являлся ассемблер --- низкоуровневый язык программирования, непосредственно отображаемый на систему команд процессора. У разработчиков был запрос на:

+ высокую производительность;
+ удобство программирования.

Традиционный на сегодня метод повышения удобства программирования через введение абстракций приводил к:

+ высоким накладным расходам (использование подпрограмм);
+ раздуванию исходного кода (inline).

Поэтому одним из путей улучшения user-experience стало наращивание системы команд с целью естественной реализации всех необходимых инструкций. Причем данное наращивание было связано не только и не столько с добавлением новых арифметических операций, сколько с созданием большого количества типовых команд. К примеру: команды, позволяющие использовать большее количество аргументов или сохранять результат не в регистр, а сразу в память и т.п. Как следствие --- для множества команд нет необходимости добавлять новую логику в процессор (шины данных, регистры, сигнальные линии), необходимо только специфическим образом использовать уже имеющуюся.

![image](https://github.com/user-attachments/assets/f704fdda-cc5a-4af7-a52e-a45a44fde78e)

Инструкции прибывают из памяти, обычно из высокоскоростного кеша. Далее они входят в декодер, который разбивает каждую инструкцию на одну или несколько микроопераций. Хотя они выполняют меньше одной инструкции, они значительно больше.
Следствие --- необходимость "программирования" системы команд процессоров, что вылилось в понятие микрокода --- программы, реализующей набор инструкций процессора. К примеру (Wikipedia):

+ Подсоединить регистр 1 ко входу A АЛУ;
+ Подсоединить регистр 7 ко входу B АЛУ;
+ Настроить АЛУ на выполнение операции сложения;
+ Установить разряд переноса АЛУ в ноль;
+ Сохранить результат операции в регистр 8;
+ Обновить коды состояния из флагов АЛУ («Отрицательное», «Ноль», «Переполнение», «Перенос»);
+ Установить указатель микрокоманд на микроинструкцию номер nnn.

Первоначально микрокод был использован в качестве более простого способа разработки управляющего устройства процессора. Прежде набор инструкций задавался жёстко, каждая машинная инструкция (сложение, сдвиг, копирование) реализовывалась непосредственно в схеме. Это давало высокую скорость, но по мере того, как набор инструкций рос, всё сложнее становилось реализовывать в виде схемы и отлаживать инструкции всё возрастающей сложности. Микрокод смягчил эту проблему тем, что позволил инженерам-проектировщикам при реализации сложной инструкции заменить создание сложной схемы на написание микропрограммы. Более того, микрокод можно было с лёгкостью изменить на поздних этапах проектирования, схему же изменить намного сложнее. Таким образом, микрокод облегчил проектирование процессоров, что привело к усложнению набора команд.

Примечания:

+ Как продать свой процессор? Нужно показать классный код на ассемблере.
+ Xerox Alto - один из знаковых компьютеров, предоставляющий программисту уровень микропрограммирования. Тот самый компьютер от Xerox wiki, Alto: A personal computer.

## NISC

Каким образом можно дальше упростить RISC-процессор? Самое простое и неочевидное решение --- угроза из-за его системной команды, как такая, обеспечившая на уровне машинного кода прямой доступ к сигналам и элементам процессора.

No instruction set computing (NISC) - это вычислительная архитектура и технология компиляции для проектирования высокоэффективных специализированных процессоров и аппаратных ускорителей, позволяющая компилятору осуществлять низкоуровневый контроль над аппаратными ресурсами. NISC (No Instruction Set Computer) не использует заранее определённый набор команд или микрокод. Компилятор генерирует нанокоды для непосредственного управления набором команд или микрокодом.

![image](https://github.com/user-attachments/assets/0132f08e-c08b-428a-873d-ac8af08ba029)

Что это позволяет сделать:

+ ISA как уровень абстракции и фактически достигает того уровня контроля за процессором, который есть в микрокоде (фактически получается программа микропрограммы, единая на всем алгоритме), что позволяет сократить количество команд (не по объему, так как из-за большого количества сигналов, как правило, программа становится больше по объему) и накладные расходы на их выполнение;
значительно упрощенный процессор, оставив в нем только те элементы, которые необходимы для вычислительных задач, перенеся, все, что возможно, в компилятор;
+ упрощение разработки процессоров, так как ограничивается сложный и трудоемкий этап проектирования ISA, но в то же время и проявляется крест на бинарной совместимости между различными процессорами (что некритично для систем на кристалле, а также для специализированного под задаче оборудования);
+ Простое определение процессора устройства позволяет сравнительно легко снизить сам процессор под задачу (допустимо для ПЛИС), а также этим обусловлено применение данной структуры в рамках [высокоуровневого синтеза](https://www.youtube.com/watch?v=mbheV9V8AbM) [( слайды )](https://drive.google.com/file/d/161Lj0fVLHgSYLQMaz0Sn_3TaYUGWYvNI/view).

