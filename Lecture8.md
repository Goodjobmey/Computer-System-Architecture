## Виды Архитектур систем комманд

В базовой модели вычислений, такой как машина фон Неймана, присутствуют центральный процессор и память. Эта модель подразумевает, что процессор может считывать данные из памяти, выполнять над ними операции и записывать результаты обратно в память.

Однако на практике реализация вычислений, опирающихся исключительно на обращение к памяти, оказывается довольно сложной. Например, даже такая простая операция, как сложение двух чисел, требует нескольких шагов: сначала необходимо считать значение из одной ячейки памяти, затем из другой, далее провести вычисление, и наконец --- записать результат обратно в память. Но даже на интуитивном уровне понятно, что такая последовательность действий требует промежуточного хранения данных. Ведь для выполнения инструкции нужно сначала её прочитать, после получить доступ к аргументам, выполнить операцию, а потом сохранить результат.

Реализация такого подхода становится затруднительной без наличия каких-либо дополнительных элементов хранения. Именно поэтому в современных процессорах обязательно присутствуют регистры --- небольшие, сверхбыстрые участки памяти, напрямую доступные вычислительным блокам. Они служат для временного хранения данных, которые участвуют в вычислениях, а также результатов этих вычислений.

Если обратиться к базовой модели виртуальной машины, то в составе ALU обычно имеются два входа и один выход. Это означает, что для выполнения любой бинарной операции процессору одновременно нужны два операнда и место для размещения результата. Очевидно, что без какой-либо формы временного хранения, будь то регистры или защёлки (latches) --- такая схема работать не сможет.
 
### Аккумуляторная архитектура

Аккумуляторная архитектура возникла одной из первых, потому очень проста. В ней для хранения одного из операндов арифметической или логической операции в процессоре имеется выделенный регистр --- аккумулятор. В этот же регистр заносится и результат операции. Изначально оба операнда хранятся в основной памяти, и до выполнения операции один из них нужно загрузить в аккумулятор. После выполнения команды обработки результат находится в аккумуляторе и, если он не является операндом для последующей команды, его требуется сохранить в ячейке памяти.

Основные компоненты такой архитектуры включают:

- Память --- для считывания и записи данных;

- АЛУ (арифметико-логическое устройство) --- для выполнения операций;

- Аккумулятор --- то специальный регистр процессора, предназначенный для временного хранения промежуточных результатов вычислений.

![Пример аккумуляторной архитектуры](вот сюда нужны наши фото)

В качестве примера рассматривается реализация классической линейной функции: `A = B + (C * D)`

```
ACC = C;
ACC = ACC * D;
ACC = ACC + B;
A = ACC; 
```

Процесс вычисления в аккумуляторной архитектуре выглядит следующим образом:

1. Инициализация аккумулятора значением переменной `C`.

2. Умножение содержимого аккумулятора на значение переменной `D`.

3. Прибавление к аккумулятору значения переменной `B`.

4. Сохранение конечного результата в адрес памяти, соответствующий переменной `A`.

Таким образом, весь вычислительный процесс строится вокруг последовательной работы с аккумулятором через простые шаги.

Преимущества аккумуляторной архитектуры:

- Простота системы команд. Архитектура подразумевает минимальный набор инструкций: аккумулятор (неявный аргумент) и адрес памяти (явный аргумент).

- Компактность инструкций. Инструкции имеют фиксированный размер и малый объём.

- Простота аппаратной реализации. Реализация процессора становится крайне простой; основная сложность заключается лишь в организации работы с памятью.

Одним из ограничений аккумуляторной архитектуры является то, что в ней есть только один аккумулятор, а значит — можно одновременно хранить лишь одно промежуточное значение. Это создаёт трудности при вычислении выражений, где требуется несколько операций с промежуточными результатами.

Рассмотрим выражение:

```
E = (A * B) + (C * D)
```

Чтобы его вычислить, нужно сначала перемножить `A` и `B`, затем `C` и `D`, а после сложить оба результата. Проблема в том, что после выполнения первой части, результат сохраняется в аккумуляторе. Но чтобы выполнить `C * D`, аккумулятору придётся загрузить другие значения, и предыдущее (результат `A * B`) будет потеряно.

Такие ограничения хорошо заметны, например, в архитектуре acc32 --- классическом представителе аккумуляторных процессоров. Схожую модель можно попробовать на практике в [wrench](https://github.com/ryukzak/wrench?tab=readme-ov-file).

### Register-to-Memory

Логичное развитие аккумуляторной архитектуре --- это Register-to-Memory. По своей сути, между ними нет принципиальной разницы, за исключением одного важного улучшения --- наличия большего количества регистров. Это позволяет значительно повысить эффективность работы процессора.

В архитектуре register-to-memory проблема частого обращения к памяти решается за счёт увеличения числа регистров. Вместо постоянных обращений к памяти данные можно сохранять и обрабатывать внутри регистров. Это упрощает и ускоряет выполнение операций. Чтобы обеспечить такую гибкость, архитектура поддерживает более сложные команды, включающие два или три операнда. Первый операнд указывает регистр-источник, второй --- регистр-назначение, а иногда третий --- дополнительный источник данных. Это позволяет, например, производить вычисления между двумя регистрами и сохранять результат в третий.

Основные особенности:

- Увеличение числа регистров. Множество регистров позволяет снизить нагрузку на память. Нет необходимости постоянно считывать и записывать данные между памятью и аккумулятором.Данные обрабатываются непосредственно в регистрах.

- Расширение системы команд. Один операнд указывает на регистр, с которым происходит операция. Два операнда позволяют разделить регистр-источник и регистр-назначение, повышая гибкость операций.

![Пример Register-to-Memory архитектуры](вот сюда нужны наши фото)

Рассмотрим задачу инкрементации массива чисел на фиксированное значение (например, на 2):

```
ACC = C;
ACC = ACC * D;
ACC = ACC + B;
A = ACC; 
```

1. Значение `2` загружается в регистр `R0`.
2. Одно из значений массива загружается в регистр `R1`.
3. Выполняется сложение содержимого `R0` и `R1`.
4. Результат сохраняется в регистр `R2`.
5. Операции повторяются для всех элементов массива в цикле.

Архитектуры аккумуляторного и регистрового типов исторически являются одними из первых моделей построения вычислительных машин. Они просты в реализации и удобны для программирования, а также позволяют относительно легко формировать машинные команды. Особенно архитектура register-to-memory оказалась весьма эффективной — её принципы до сих пор применяются в современных CISC-процессорах, где активно используются регистры в сочетании с памятью.

### Register-to-Register

В архитектуре Register-to-Memory на каждом такте выполняется доступ к памяти, что вызывает задержку, так как память работает медленнее процессора и регистров.

Одной из ключевых проблем архитектуры вычислительных систем является несоответствие скоростей между процессором и оперативной памятью, что вызывает задержки при обращении к данным. Современные процессоры работают на значительно более высоких частотах, чем память. Для устранения этого разрыва используется кэш-память, которая служит высокоскоростным буфером между процессором и памятью, обеспечивая быстрый доступ к часто используемым данным. В случае промаха кэша происходит обращение к основной памяти, что снова вызывает задержки. Несмотря на развитие кэш-архитектур, проблема скорости доступа к памяти остаётся актуальной.

По мере увеличения разрыва между скоростью процессоров и памяти возникла задача: Как сделать так, чтобы обращения к памяти происходили как можно реже?

Решением стало развитие архитектуры, в которой все операции выполняются исключительно на регистрах.

Архитектура типа Register-to-Register строится на ряде чётко определённых принципов, обеспечивающих эффективность и структурированность вычислительного процесса. 

1) В первую очередь, все необходимые данные предварительно загружаются из оперативной памяти в регистры процессора. Это позволяет минимизировать количество обращений к относительно медленной памяти во время выполнения операций.
2) Далее, все арифметические и логические вычисления происходят исключительно между регистрами, что существенно ускоряет обработку данных за счёт высокой скорости работы с регистрами.
3) Завершающим этапом является сохранение полученных результатов обратно в память, если они необходимы за пределами текущих вычислений. Такой подход делает Register-to-Register архитектуру особенно эффективной для современных высокопроизводительных систем, где критически важна скорость обработки и строгое разделение стадий загрузки, вычислений и сохранения данных.

![Пример Register-to-Register архитектуры](вот сюда нужны наши фото)

Преимущества Register-to-Register архитектуры:

- Высокая скорость выполнения операций. Операции на регистрах происходят значительно быстрее, так как регистры имеют мгновенный доступ.

- Эффективная схемотехника. Поскольку регистров ограниченное количество, их можно эффективно связать мультиплексорами для быстрого выбора нужных данных.

-  Минимизация времени выполнения инструкций. Инструкции, работающие только с регистрами, могут выполняться за очень малое количество тактов (порой менее чем за два такта).

-  Компактность инструкций. Для адресации регистров требуется значительно меньше бит по сравнению с адресацией памяти. Например, если доступно 32 регистра, для указания каждого понадобится всего 5 бит. Таким образом, для указания двух операндов и результата достаточно 15 бит, а оставшееся место в инструкции используется для кодирования операции (опкода).

Пример линейной функции `Y = A * X + B`:

```
load R1 <- A      
load R2 <- X      
load R3 <- В
mul R4 <- R1 * R2
add R5 <- R4 + R3
store Y <- R5
```

1. Данные загружаются из памяти в регистры:

   * `load R1 <- A`
   * `load R2 <- X`
   * `load R3 <- B`

2. Выполняются вычисления исключительно между регистрами:

   * `mul R4 <- R1 * R2`
   * `add R5 <- R4 + R3`

3. Результат вычислений сохраняется обратно в память:

   * `store Y <- R5`

Все операции разделены на этапы: сначала загрузка данных в регистры, затем вычисления, и в конце запись результата в память. Такой подход упрощает разграничение операций с памятью и вычислений, делая архитектуру более прозрачной и предсказуемой. Также этот подход позволяет эффективно использовать параллелизм: пока одни данные загружаются в регистры, другие могут одновременно обрабатываться. Поскольку все операции выполняются исключительно между регистрами, они становятся короче, быстрее и проще как для аппаратной реализации, так и для компиляции. В результате Register-to-Register архитектура повышает производительность процессоров, минимизируя задержки при доступе к памяти.

Из-за использования регистров возникает дополнительная задержка при работе с памятью. Каждое чтение и запись буферизуются в регистре на один такт, прежде чем попадут с шины памяти в чип, поэтому регистровая память считается на один такт более медленной, чем нерегистровая.

### Memory-to-Memory

Одним из альтернативных направлений развития компьютерной архитектуры стала модель Memory-to-Memory. В отличие от Register-to-Register подхода, где все вычисления происходят только между регистрами, эта архитектура позволяет инструкциям напрямую взаимодействовать с ячейками оперативной памяти. Каждая операция здесь может включать сразу несколько этапов: считывание исходных данных из одной области памяти, выполнение вычислений внутри процессора и запись полученного результата обратно в другую область памяти. Таким образом, одна инструкция совмещает в себе сразу три действия — загрузку, обработку и сохранение — что делает машинный код более компактным. Такой подход упрощает программирование на низком уровне и уменьшает количество промежуточных шагов, хотя и может снижать производительность из-за постоянного обращения к памяти, которая работает медленнее регистров. Тем не менее, Memory-to-Memory архитектура остаётся интересной с точки зрения гибкости и лаконичности выражения операций.

![Пример Memory-to-Memory архитектуры](вот сюда нужны наши фото)

**Преимущества Memory-to-Memory архитектуры:**

- Удобство для низкоуровневого программирования. При разработке на ассемблере Memory-to-Memory архитектура позволяет писать код, который напрямую отражает алгоритмическую суть программы.

- Эффективность инструкций. Одна инструкция выполняет сразу несколько операций, что уменьшает накладные расходы на кодирование и интерпретацию инструкций.

- Читаемость и простота отладки. Программы на такой архитектуре легко читаются, а псевдокод высокого уровня можно почти напрямую транслировать в машинные инструкции.

**Недостатки Memory-to-Memory архитектуры:**

- Ограниченная эффективность кэширования. Кэш-память — это один из ключевых механизмов ускорения доступа к данным в современных процессорах. Её основная задача — уменьшить разрыв в скорости между быстрыми регистрами и сравнительно медленной оперативной памятью (RAM). За счёт хранения недавно или часто используемых данных в специальных сверхбыстрых областях памяти (L1, L2, L3 кэши), кэш позволяет обрабатывать информацию без постоянного обращения к основной памяти, которое сопровождается большими задержками.
 
- Сложность системы команд. Архитектура Memory-to-Memory порождает богатую и разнообразную систему команд. Инструкции быстро обрастают дополнительной функциональностью (например, "прочитать и инкрементировать"). Реализация такой сложной логики на уровне аппаратуры требует значительных затрат ресурсов и времени.

Пример системы команд и линейной функции `Y = A * X + B`:

```
lnf Y<- A * X + B   ; mem-to-mem
                    ; 3 operands 
```

Процесс выполнения инструкции можно представить следующим образом: сначала процессор считывает значения из двух ячеек памяти — `A` и `X`, после чего выполняет умножение этих значений. Затем из памяти извлекается значение `B`, которое прибавляется к результату предыдущей операции. Полученное значение записывается обратно в память по адресу `Y`. Таким образом, одна единственная инструкция охватывает сразу три этапа: чтение данных из памяти, вычисление результата внутри процессора и запись результата обратно в память.

### Стековая архитектура

Отдельным направлением развития стала стековая архитектура. Она отличается компактностью команд и особенно эффективна для определённых типов вычислений. В её основе лежит принцип использования стековой памяти, размещённой непосредственно внутри процессора, вместо традиционного набора регистров. Стек представляет собой совокупность связанных между собой ячеек памяти, функционирующих по принципу «последним вошёл — первым вышел» (LIFO, Last In First Out). При этом операции обычно выполняются над двумя верхними элементами стека, что позволяет обходиться без явного указания аргументов — они неявно берутся с вершины стека.

![Пример Стековой архитектуры](вот сюда нужны наши фото)

**Преимущества стековой архитектуры**:

- Естественная поддержка процедур. Аргументы функций передаются посредством стека без необходимости использования ограниченного числа регистров, что особенно актуально при глубокой вложенности вызовов. Это избавляет от необходимости введения соглашений об использовании регистров, все необходимые данные просто помещаются в стек.
- Простота реализации. Стековая архитектура характеризуется простотой реализации и минималистичным машинным кодом, что упрощает проектирование процессоров.

**Недостатки стековой архитектуры**:

- Неудобство произвольного доступа. В случае необходимости обращения к элементам стека, расположенным не на вершине, возникает необходимость выполнения дополнительных операций, что приводит к увеличению количества команд. Для частичного решения этой проблемы могут использоваться несколько стеков или дополнительные регистры.

- Сложности в оптимизации. Ограничение работы только с вершиной стека затрудняет распараллеливание операций, что снижает производительность и ограничивает возможности ускорения выполнения программ.
  
- Компактность команд. Машинный код получается коротким и эффективным.

Стековая организация вычеслений часто применяеся в реализации интерпретаторов, поскольку построение виртуальных машин на основе стека является удобным и эффективным решением.

Пример системы команд и линейной функции `Y = A * X + B`:

```
A @ X @ *   \ stack, 0 operands
B @ + Y !   \ @ - read, ! - write 
```

* `@` --- операция чтения: извлекает значение из памяти по указанному адресу и помещает его на вершину стека;
* `*`, `+` --- арифметические операции: берут два верхних значения со стека, применяют операцию и помещают результат обратно;
* `!` --- операция записи: снимает значение с вершины стека и сохраняет его в указанную ячейку памяти.

Пошаговое выполнение:

1. `A @` --- считывает значение из памяти по адресу `A` и помещает его на стек;
2. `X @` --- аналогично, значение из `X` добавляется на вершину стека;
3. `*` --- перемножает два верхних значения (то есть `A * X`) и кладёт результат обратно;
4. `B @` --- значение из памяти по адресу `B` загружается в стек;
5. `+` --- складывает два верхних значения (`A * X + B`);
6. `Y !` --- сохраняет итоговое значение в память по адресу `Y`.

## Машина фон-Неймана

Машина фон Неймана представляет собой абстрактную модель вычислительной системы, поскольку многие элементы её архитектуры изначально не были конкретизированы. Это сделано намеренно, чтобы не ограничивать творческий подход инженеров-разработчиков при создании новых вычислительных систем. Таким образом, архитектура машины фон Неймана описана не на уровне внутренней реализации, а на концептуальном уровне представления вычислительного процесса.
Рассмотрим более конкретную организацию архитектуры фон Неймана:

![Машина фон Неймана](fig/von-neumann-example.png)

Описание:

- Разрядность процессора: 8 бит.
- Организация памяти: гарвардская, с отдельными блоками памяти для команд и данных.
- Внешние устройства (для данной работы это светодиоды, двухпозиционные переключатели и тактовые кнопки) отображаются в адресное пространство данных. Работа с ними выполняется по опросу.
- Регистры:
    - `PC` --- регистр счётчика команд (Program Counter) указывает адрес текущей инструкции, при этом общее количество возможных инструкций составляет 256.
    - `IR` --- регистр инструкций (Instruction Register), предназначен для хранения активной команды или операционного кода, поступающего из памяти команд.
    - `AR` --- регистр адреса операнда (Address Register) содержит адрес памяти, который будет использован в следующих тактах.
    - `C` --- флаг переноса/заёма
    - `Z` --- флаг нуля
- Команды выполняются за 2 или 3 такта (в зависимости от типа команды):
    1. Выборка команды
    2. Выборка операндов
    3. Выполнение команды.
- Подсистема обработки прерываний и команды вызова подпрограмм отсутствует.
- В архитектуре предусмотрен мультиплексор (MUX2), который позволяет выбирать источник данных для левого входа арифметико-логического устройства (АЛУ): либо данные из памяти данных, либо данные из памяти команд. Второй аргумент для АЛУ поступает исключительно из аккумулятора, в который затем записывается результат вычислений.

[Пример модели процессора на Haskell](http://amazing-new-gate.blogspot.com/2010/07/haskell.html)

Код на ассемблере:

```
add #01 <- 34 + #03

асс <- 34
асс <-  #03.
#01 <- acc
```

В рассмотренном примере с операцией `ADD #01 <- 34 + #03` демонстрируется выполнение команды сложения с непосредственным значением и операндом из памяти, результат которого сохраняется по заданному адресу. Данная инструкция содержит четыре байта: один — для операционного кода, и по одному — для каждого из трёх аргументов (константы, адреса операнда и адреса результата). Такая организация кода выбрана не из стремления к экономии памяти, а в целях наглядности и универсальности: инструкция полностью самодостаточна и не ограничена восьмибитной адресацией или жёстко заданной структурой регистров.

Первым байтом поступает операционный код, он сообщает блоку управления, какие управляющие сигналы необходимо сгенерировать на протяжении выполнения инструкции. Следом идут аргументы: непосредственно значение `34`, адрес ячейки `03`, откуда берётся второй операнд, и адрес `01`, куда будет записан результат. Таким образом, один короткий фрагмент кода содержит все необходимые данные для операции, без необходимости дополнительных инструкций.

Потактовое исполнение:

```
; --- 1. Чтение инструкции

IR <- PMem[ PC]
PC <- PC+1

; --- 2. Инициализация акк. 34

{ Acc, Z, C } <- ALU( ... )
              <-  MUX2( ... )
              <- PMem [PC]
PC + PC+1

; --- 3. Выгрузка адреса 03

AR <- PMem[ PC]
PC <- PC+1

; --- 4. Выгрузка адреса 01 
; ---     Выгрузка #03 и сложение

AR <- PMem[PC]
{ Acc, Z, C } <- ALU( ... )
              <- MUX2 ( ... ) 
              <- DMem[AR].DOUT
PC <- PC+1

; --- 5. Сохранение результата

DMem[AR].DIN <- Acc
```

Если бы в данной архитектуре использовалась классическая аккумуляторная схема, процесс усложнился бы. Понадобились бы отдельные инструкции на загрузку константы в аккумулятор, извлечение второго операнда и сохранение результата. Это потребовало бы больше памяти — уже не четыре, а шесть байт, и увеличило бы длительность выполнения команды минимум до восьми тактов. Такое дублирование инструкций, характерное для аккумуляторных архитектур, снижает общую эффективность исполнения кода.

В выбранной архитектуре выполнение инструкции делится на последовательность тактов, каждый из которых реализует конкретный этап обработки:

1. В первом такте происходит выборка инструкции из памяти команд. Программный счётчик (PC) указывает на текущий адрес, память команд (PMem), как комбинационная схема, мгновенно возвращает байт команды по данному адресу. Этот байт защёлкивается в регистр инструкции (IR), а сам PC тут же инкрементируется. Это важно: через один такт нужно будет читать следующий байт — первый аргумент, и если счётчик не увеличить вовремя, произойдёт сбой.

2. Во втором такте происходит загрузка непосредственного значения `34` в аккумулятор. Оно извлекается из PMem, проходит через мультиплексор к ALU и сразу записывается в аккумулятор. ALU, будучи комбинационной схемой, мгновенно реагирует на входные данные, формируя выход. Параллельно вновь происходит инкремент PC для подготовки к следующему байту.

3. В третьем такте считывается первый адрес операнда, равный `03`. Это значение поступает из PMem и защёлкивается в адресный регистр (AR). Снова инкрементируется PC. Заметим, что в этом и предыдущих тактах данные из PMem не защёлкиваются в AR автоматически: отсутствие управляющего сигнала защёлки мешает этому процессу, что подчёркивает важность сигналов управления.

4. В четвёртом такте осуществляется двойное действие. Сначала считывается следующий байт из PMem — адрес результата, `01`. Он защёлкивается в AR. Одновременно ALU выполняет операцию сложения: на его входах находятся данные из аккумулятора (значение `34`) и значение из памяти данных (DMem) по адресу `03`. Сумма тут же защёлкивается обратно в аккумулятор. Этот параллелизм подчёркивает высокую эффективность схемы: при правильной организации управления обработка данных и извлечение инструкций происходят синхронно. После завершения этого такта PC вновь инкрементируется.

5. В пятом такте происходит завершение операции: результат из аккумулятора передаётся через шину данных в память данных (DMem) по адресу, который уже содержится в AR. Параллельно инициируется чтение следующей инструкции из памяти команд, что является примером перекрытия инструкций (instruction overlap) — принципа, лежащего в основе конвейерной обработки. Последний такт текущей инструкции совпадает с первым тактом следующей, уменьшая время простоя и повышая общую производительность.

Эта схема демонстрирует практические принципы работы процессора и подчёркивает влияние архитектурных решений на эффективность вычислений. Простое изменение порядка операций, применение параллелизма и жёсткий контроль над управляющими сигналами позволяют ускорить выполнение инструкций и сократить объём исполняемого кода. Переход от традиционной аккумуляторной архитектуры к гибкой памяти-регистр структуре приводит к ощутимому увеличению производительности без необходимости значительной модификации аппаратной части. Всё это делает подобную архитектуру более выгодной как с точки зрения скорости, так и с точки зрения рационального использования ресурсов.

Вот так на практике и рождаются системы типа CISC --- Complex Instruction Set Computer.

## Complex Instruction Set Computer

Complex Instruction Set Computing (CISC) --- архитектура процессора с полным набором команд, в которой отдельные инструкции способны выполнять несколько операций низкого уровня (например, загрузку из памяти, арифметические вычисления и сохранение обратно в память) или многошаговые процедуры в рамках одной инструкции. Основоположником CISC-архитектуры считается компания IBM с архитектурой IBM/360. Типичными примерами CISC-процессоров являются x86, Motorola MC680x0, Zilog Z80 и мейнфреймы серии zSeries.

Основная идея CISC заключалась в стремлении обеспечить максимально эффективное управление процессором. Для этого систему команд усложнили, чтобы минимизировать количество лишних операций при выполнении задач. Архитектура стремилась к тому, чтобы каждая типовая операция обработки данных имела свою специализированную машинную команду. Это позволило упростить процесс программирования на низкоуровневых языках и существенно сократить объем разрабатываемого кода.

Одним из факторов, способствовавших развитию CISC, стало внедрение микропрограммного управления. Микропрограммы позволяли сравнительно просто формировать сложные команды и расширенные режимы адресации без значительных затрат на аппаратную реализацию. Благодаря этому стало возможным поддерживать различные режимы адресации для всех типов команд, реализовывать сложные арифметические операции в рамках одной инструкции и создавать потоковые операции обработки данных.

Микропрограммное управление также обеспечивало возможность обновления и оптимизации работы процессора после его выпуска за счёт изменения микрокода, как это было реализовано, например, в системах семейства УВК «Самсон» для РВСН.

**Причины появления архитектуры CISC**

Архитектура CISC сформировалась как ответ на ряд технологических и практических вызовов, актуальных на ранних этапах развития вычислительной техники. Её появление и широкое распространение были обусловлены следующими факторами. Во-первых, в эпоху становления CISC-процессоров высокоуровневые языки программирования ещё не получили широкого распространения. Основное программирование велось на ассемблере, что делало наличие расширенного и функционально насыщенного набора команд особенно актуальным — он упрощал написание программ и повышал удобство разработки. Во-вторых, в условиях значительных различий между архитектурами различных вычислительных систем универсальные и мощные команды позволяли частично нивелировать архитектурные различия, способствуя повышению степени переносимости программного обеспечения.

Кроме того, на тот момент компиляторы обладали ограниченными возможностями по оптимизации кода. Это накладывало необходимость переноса части задач по управлению ресурсами и эффективному выполнению операций непосредственно на уровень аппаратного обеспечения. Расширенные инструкции процессоров позволяли реализовывать сложные логические и арифметические операции с минимальными усилиями со стороны программиста и без участия развитых инструментов трансляции. Также стоит отметить, что за счёт использования сложных и многофункциональных инструкций удавалось существенно сократить объём исходного кода, что повышало удобство программирования и облегчало отладку. Это, в свою очередь, вело к экономии объёма памяти, которая в тот период являлась дорогостоящим и ограниченным ресурсом. Наконец, возможность выполнять комплексные операции за один цикл программной логики способствовала снижению накладных расходов, связанных с обращениями к памяти и перемещением данных внутри системы, тем самым повышая общую производительность вычислительных процессов.

Таким образом, архитектура CISC была логичным ответом на ограниченные ресурсы и инструменты программной инженерии своего времени, сочетая в себе удобство, универсальность и эффективность.

**Преимущества архитектуры CISC**

- Удобство использования ассемблера для написания программ.
- Снижение затрат на доступ к памяти команд благодаря более коротким программам.
- Возможность обновления микрокода для улучшения функциональности процессора.
- Возможность оптимизации микрокода для конкретных алгоритмов, сокращение объема программ и устранение лишних операций.

**Недостатки архитектуры CISC**

- Сложность системы команд: Большое количество команд делает их полное освоение и эффективное использование сложной задачей для программистов и компиляторов.
- Усложнение устройства процессора и блока управления: Наличие множества инструкций, способов адресации и аргументов приводит к значительному усложнению схем управления процессором.
- Сложность генерации эффективного машинного кода: Автоматические компиляторы испытывают трудности в создании оптимального кода для CISC-процессоров.
- Высокая стоимость хранения микрокода: Микропрограммы требуют размещения в быстрой внутренней памяти процессора, что увеличивает стоимость чипа.
- Повышенные требования к разработчикам: Разработка и сопровождение сложных систем команд требуют глубоких знаний архитектуры процессора.
- Сложности оптимизации производительности: Большое разнообразие команд и их неоднородность затрудняют реализацию высокоэффективных методов обработки, таких как конвейеризация и суперскалярность.
- Высокая стоимость разработки микрокода: Программирование микрокода требует значительных затрат на отладку и оптимизацию.

Несмотря на выявленные недостатки, архитектура CISC продолжает активно использоваться ведущими производителями процессоров (Intel, AMD, IBM). В современных CISC-процессорах применяются гибридные подходы, сочетающие принципы CISC и RISC для достижения максимальной производительности.

![CISC](fig/cisc.png){ width=50% }

## Микрокод

При проектировании CISC-процессоров приоритетным направлением является разработка устройства процессора и блока управления (Control Unit), поскольку реализация конечного автомата, способного поддерживать сложную систему команд, представляет собой исключительно сложную задачу с аппаратной точки зрения.

Существует два основных подхода к реализации Control Unit:

- Hardwired (жёстко заданный) --- управление реализуется через комбинационные схемы, декодирующие инструкции в последовательности управляющих сигналов. Блок управления использует фиксированный набор логических вентилей и схем, при этом каждая инструкция имеет заранее заданную жёсткую реализацию. Hardwired-блоки просты и быстры, однако они обладают малой гибкостью и трудны для модификации.

- Microcoded (микропрограммный) --- управление осуществляется посредством исполнения микропрограммы, управляющей выполнением инструкций. Внутри процессора размещается очень быстрая память, в которой хранится микрокод, управляющий всеми процессами на уровне выполнения инструкций.

Микрокод —-- это программа, реализующая набор инструкций процессора. Подобно тому, как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в микрокодируемом процессоре каждая машинная инструкция превращается в последовательность микроинструкций. Микрокод служит промежуточным уровнем между аппаратной реализацией процессора и видимой программисту архитектурой набора инструкций.

Микрокод хранится в памяти только для чтения (ROM), которая значительно дешевле оперативной памяти. Это позволяет выгодно использовать постоянную память, снижая потребность в более дорогих компонентах.

Размещённый в специализированной высокоскоростной памяти, микрокод преобразует машинные инструкции или другие входные данные в последовательности детализированных низкоуровневых операций. Микрокод позволяет отделить реализацию инструкций от базовой электроники, обеспечивая гибкость в проектировании и возможностях модификации. Он также упрощает реализацию сложных многошаговых инструкций, одновременно снижая общую сложность аппаратуры.

Процесс написания микрокода называют микропрограммированием. В конкретной реализации процессора микрокод часто называют микропрограммой. Основная идея микрокода заключается в замене специализированной аппаратной логики серией простых микроинструкций, выполняемых движком микрокода. В этом движке каждая микроинструкция последовательно активирует необходимые управляющие сигналы. Микрокод может быть битово закодирован, где каждый бит отвечает за определённую управляющую линию, аналогично тому, как отверстия на перфорированном рулоне механического пианино управляют звучанием клавиш.

Первые процессоры могли быть реализованы полностью аппаратно, а основным языком программирования был ассемблер, напрямую соответствующий системе команд процессора. Разработчики стремились одновременно к высокой производительности и удобству программирования.
Попытки повысить удобство через введение дополнительных абстракций приводили к:

- высоким накладным расходам (например, через активное использование подпрограмм);
- раздуванию исходного кода (например, при широком использовании inline-функций).

Одним из путей улучшения пользовательского опыта стало расширение набора инструкций, позволяющее естественно и без дополнительных накладных расходов реализовывать частые операции. Это расширение включало:

- добавление команд с увеличенным числом аргументов;
- команды для непосредственной работы с памятью без обязательного сохранения результата в регистр.

Как следствие, расширение набора команд не требовало радикальных изменений в архитектуре процессора (таких как новые шины данных или регистры), а лишь специфического использования уже существующих аппаратных ресурсов.

![Микрокод]( fig/microcode-decode.png )

Инструкции прибывают из памяти, обычно из высокоскоростного кеша. Далее они входят в декодер, который разбивает каждую инструкцию на одну или несколько микроопераций. Хотя они выполняют меньше одной инструкции, они значительно больше.
Следствие --- необходимость "программирования" системы команд процессоров, что вылилось в понятие микрокода --- программы, реализующей набор инструкций процессора. К примеру (Wikipedia):

- Подсоединить регистр 1 ко входу A АЛУ;
- Подсоединить регистр 7 ко входу B АЛУ;
- Настроить АЛУ на выполнение операции сложения;
- Установить разряд переноса АЛУ в ноль;
- Сохранить результат операции в регистр 8;
- Обновить коды состояния из флагов АЛУ («Отрицательное», «Ноль», «Переполнение», «Перенос»);
- Установить указатель микрокоманд на микроинструкцию номер nnn.

Первоначально микрокод был использован в качестве более простого способа разработки управляющего устройства процессора. Прежде набор инструкций задавался жёстко, каждая машинная инструкция (сложение, сдвиг, копирование) реализовывалась непосредственно в схеме. Это давало высокую скорость, но по мере того, как набор инструкций рос, всё сложнее становилось реализовывать в виде схемы и отлаживать инструкции всё возрастающей сложности. Микрокод смягчил эту проблему тем, что позволил инженерам-проектировщикам при реализации сложной инструкции заменить создание сложной схемы на написание микропрограммы. Более того, микрокод можно было с лёгкостью изменить на поздних этапах проектирования, схему же изменить намного сложнее. Таким образом, микрокод облегчил проектирование процессоров, что привело к усложнению набора команд.

Примечания:

- Как продать свой процессор? Нужно показать классный код на ассемблере.
- Xerox Alto - один из знаковых компьютеров, предоставляющий программисту уровень микропрограммирования. Тот самый компьютер от Xerox [wiki](https://en.wikipedia.org/wiki/Xerox_Alto), [Alto: A personal computer](http://people.scs.carleton.ca/~soma/distos/fall2008/alto.pdf).

## No Instruction Set Computing

No instruction set computing (NISC) --- это вычислительная архитектура и технология компиляции для проектирования высокоэффективных специализированных процессоров и аппаратных ускорителей, позволяющая компилятору осуществлять низкоуровневый контроль над аппаратными ресурсами. NISC (No Instruction Set Computer) не использует заранее определённый набор команд или микрокод. Компилятор генерирует нанокоды для непосредственного управления набором команд или микрокодом.

Если мы посмотрим на процессор и зададимся вопросом: "А зачем нам вообще нужны инструкции?", становится очевидным, что процессор в реальности управляется микроинструкциями. Тогда возникает идея: отказаться от этапа компиляции в машинные инструкции и вместо этого компилятору сразу выдавать трассы микроинструкций, которые напрямую загоняются в процессор для управления.

В классическом CISC-процессоре (схема предоставлена в [соответсвующем разделе](#Complex-Instruction-Set-Computer)) мы видим:

- Program Counter
- Program Memory
- Micro Program Counter
- Micro Program Memory
- Управляющие слова

Если удалить этап с Micro Program Counter и Micro Program Memory, останется только Program Counter и Program Memory. Это позволяет значительно упростить процессор. Теперь компилятор, понимая что именно он делает, может сразу генерировать оптимальный для конкретной аппаратуры код.

![NISC](fig/nisc.png){ width=50% }

Преимущества такого подхода:

- Значительное упрощение аппаратной части.
- Максимальная эффективность программного управления.
- Отсутствие необходимости в проектировании и поддержке ISA (Instruction Set Architecture), так как управляющие сигналы напрямую задаются железом.
- ISA в таком подходе становится фактически уровнем абстракции, который обеспечивает контроль за процессором на уровне микрокода. Это позволяет сократить количество типов команд (хотя общий объём программы может увеличиваться за счёт количества управляющих сигналов) и снижает накладные расходы на выполнение инструкций.
- Упрощение разработки процессоров: устраняется сложный и трудоёмкий этап проектирования ISA, что особенно важно для специализированного оборудования. Однако одновременно исчезает бинарная совместимость между различными процессорами — что, впрочем, некритично для систем-на-кристалле и узкоспециализированных решений.
- Упрощение структуры процессора: оставляются только элементы, необходимые для выполнения вычислений, а всё возможное переносится на уровень компилятора.
- Благодаря простой структуре процессора становится возможным его сравнительно лёгкая адаптация под конкретные задачи, особенно в системах на ПЛИС (FPGA), что обусловливает применение данной архитектуры в рамках [высокоуровневого синтеза](https://www.youtube.com/watch?v=mbheV9V8AbM) ([слайды](https://drive.google.com/file/d/161Lj0fVLHgSYLQMaz0Sn_3TaYUGWYvNI/view)).

Несмотря на определённые преимущества стековой архитектуры, такие как компактность выражения операций и простота реализации, у неё имеются и существенные недостатки, ограничивающие её широкое применение в современных вычислительных системах.

Во-первых, возникает проблема отсутствия бинарной совместимости. Для корректного исполнения сгенерированного машинного кода требуется, чтобы внутреннее устройство целевого процессора полностью совпадало с тем, для которого этот код был разработан. Это связано с тем, что в стековой архитектуре отсутствует чёткое разделение между архитектурой и микроархитектурой процессора: способ представления команд, структура стека и даже порядок выполнения операций могут быть глубоко привязаны к конкретной реализации. В результате компиляторы, программисты и производители аппаратного обеспечения вынуждены тесно координировать свои действия, что исключает возможность их независимого развития и делает переносимость кода крайне затруднительной.

Во-вторых, данная модель демонстрирует низкую плотность машинного кода. Управляющие слова, используемые для кодирования операций, часто содержат множество нулевых битов, не несущих полезной информации. Эти «пустые» участки загружают внутреннюю память процессора, расходуют ресурсы шин передачи данных и увеличивают объём передаваемой информации. В условиях, когда эффективность работы процессора всё чаще зависит от скорости обмена данными и экономного использования памяти, такие накладные расходы становятся серьёзным ограничением.

На практике для борьбы с низкой плотностью кода иногда применяются аппаратные архиваторы, которые позволяют хранить программу в сжатом виде и распаковывать её на лету. Несмотря на это, подобный подход остаётся экзотическим и применяется в основном в специфических задачах, где процессоры проектируются под конкретное применение.

Есть две основных области применения таких идей:

- Высокоуровневый синтез (HLS, High-Level Synthesis). Это специальные САПР-инструменты, которые позволяют на основе программы на языке C автоматически сгенерировать цифровую схему, реализующую алгоритм. Такой подход значительно упрощает проектирование цифровой обработки сигналов и других специализированных вычислений, хотя инструменты HLS остаются сложными в использовании. Под капотом они часто используют низкоуровневую архитектуру: микропрограммное управление плюс датапас, где микропрограмма координирует действия датапаса в зависимости от скомпилированного алгоритма.

- CGRA-процессоры (Coarse-Grained Reconfigurable Architectures). Эти архитектуры потенциально представляют будущее вычислительной техники. Мы коснёмся этой темы ближе к концу семестра, в рамках проекта по разработке САПРов для спецпроцессоров.
  
