# [Конспект лекции №8](https://www.youtube.com/watch?v=Iko9CJl2MwQ)

## ISA Overview

Как вы можете представить, количество инструкций, которые понимает процессор, ограничено. Если вы знакомы с программированием, вы знаете, что можно определять собственные функции. Так вот, машинные команды не имеют такой возможности.

Существует фиксированное количество команд, которые понимает процессор. И вы как программист не можете его расширить.

В мире представлено множество различных микропроцессоров, и они не используют одинаковый набор команд. Иными словами, они интерпретируют числа в инструкции по-разному.

Одна архитектура микропроцессора трактует число 501012 как add r10, r12, а другая архитектура — как load r10, 12. Комбинация инструкций, которые понимает процессор, и регистров, которые ему доступны, называется архитектурой набора команды (Instruction Set Architecture, ISA).

### Аккумуляторная архитектура

Аккумуляторная архитектура возникла одной из первых и к тому же очень проста. В ней для хранения одного из операндов арифметической или логической операции в процессоре имеется выделенный регистр — аккумулятор. В этот же регистр заносится и результат операции. Изначально оба операнда хранятся в основной памяти,и до выполнения операции один из них нужно загрузить в аккумулятор. После выполнения команды обработки результат находится в аккумуляторе и, если он не является операндом для последующей команды, его требуется сохранить в ячейке памяти.

![image](https://github.com/user-attachments/assets/3b4bf477-2050-4816-adf1-e7e12b9750e3)
### Регистровая архитектура

Данная архитектура является логическим продолжением аккумуляторной и особо не отличается, заисключением того, что теперь заместо одного аккумулятора у нас будет много регистров.

Микропроцессор с архитектурой данного типа включает в себя массив регистров, известных как регистры общего назначения. В микропроцессоре отсутствует специальный регистр данных, выполняющий функции аккумулятора. Функции аккумулятора выполняет один из регистров общего назначения.

Размер регистров обычно фиксирован и совпадает с размером машинного слова.К любому регистру можно обратиться,указав его номер. Регистровая архитектура допускает расположение операндов в одном из двух пространств: основной памяти или регистрах. С учетом возможного размещения операндов в рамках регистровых архитектур выделяют три типа команд обработки: Register-to-Register, Register-to-Memory, Memory-to-Memory.

#### Register-to-Memory
![image](https://github.com/user-attachments/assets/b8bddab3-d0bc-420d-a86d-b8c306bf171e)
#### Register-to-Register
![image](https://github.com/user-attachments/assets/3a0a9c2f-3f3a-40a9-aa31-ae3f3586ed6b)
#### Memory-to-Memory
![image](https://github.com/user-attachments/assets/558199b1-316e-4727-aad2-ca919c05520a)
### Стековая архитектура
![image](https://github.com/user-attachments/assets/43be07b5-7655-40ab-aba3-b935a9dea4d2)

## Процессор фон-Неймана

## Complex Instruction Set Computer
CISC - это компьютерная архитектура, в которой отдельные инструкции могут выполнять несколько операций низкого уровня (загрузка из памяти, арифметическая операция и сохранение в памяти) или способны выполнять многошаговые операции или режимы адресации в рамках отдельных инструкций.

Методика построения системы команд CISC противостоит методике, применяемой в другом распространённом типе процессорных архитектур — RISC, где используется набор упрощённых инструкций. Типичными представителями CISC-архитектуры являются процессоры на основе команд x86, процессоры Motorola MC680x0, Zilog Z80, процессоры мейнфреймов zSeries.

В конце 1970, когда началась разработка CISC-процессоров, память была очень дорогой. Компиляторы тоже были плохие, а люди писали на ассемблере.
Так как память была дорогой, люди искали способ минимизировать использование памяти. Одно из таких решений — использовать сложные инструкции процессора, которые делают много действий. Это также помогло программистам на ассемблере, так как они смогли писать более простые программы, ведь всегда найдется инструкция, которая выполняет то, что нужно. Через некоторое время это стало сложным. Проектирование декодеров для таких команд стало существенной проблемой. Изначально ее решили с помощью микрокода.

Архитектура CISC в значительной степени стала возможна благодаря возможностям микропрограммного управления. Микропрограмма позволяет относительно легко (по сравнению с разработкой аппаратуры) формировать большое количество команд со сложным поведением. Поднять уровень машинных инструкций ближе к уровню языков программирования высокого уровня. К примеру:

+ относительно легко поддержать все интересующие варианты адресаций для всех типов команд;
+ реализовать операции с произвольным набором аргументов, к примеру, инструкцию для расчета многочленов в рамках одной инструкции;
+ реализовать операции, работающие в потоковом режиме.

Основными преимуществами такого подхода являются:

+ удобство использования ассемблера как инструмента программирования;
+ сокращение затрат на доступ к памяти команд, так как гибкость позволяет сократить количество инструкций;
+ возможность обновления микропрограммного управления позволяет обновить "прошивку" процессора, и тем самым улучшить его функциональность уже после производства аппаратуры;
  + Существуют семейства процессоров и инструментальных средств для них, активно эксплуатирующие данную возможность, к примеру: УВК «Самсон» – базовая ЭВМ РВСН. Оптимизация микрокода под конкретный алгоритм позволяет сократить объём программ (машинное представление), а также оптимизировать лишние операции.

Но также он сопряжён с рядом недостатков:

+ Необходимо хранить микрокод непосредственно в процессоре (необходим мгновенный доступ к нему), где хранение данных --- весьма дорогой процесс, по сравнению с внешней памятью. Чем сложнее система команд, тем больше необходимо памяти.
+ Развитый ассемблер требует большого объёма знаний о процессоре от разработчика. Кроме того, лёгкость развития и модернизации системы команд провоцирует рост разнообразия процессорных архитектур, что, в свою очередь, накладывает серьёзные требования на инструментальные средства.
+ Наличие большого количества программного обеспечения (пусть и в виде микрокода) сопряжено со всеми сложностями программирования. В данном случае это означает, что программное обеспечение нуждается в дорогостоящей отладке и оптимизации, что значительно повышает стоимость разработки.
+ Большое разнообразие команд делает их относительно уникальными с точки зрения формата, размера команды, длительности исполнения и количества доступов к памяти. Как следствие это усложняет:

  + реализацию оптимизаций в рамках процессора (конвейерное исполнение, суперскалярность и т.п.);
  + поддержку со стороны инструментальных средств (компиляторы, дизассемблеры, отладчики и т.п.), в качестве примера можно посмотреть о сложностях разработки дизассемблеров для современных процессоров x86.

Примечание: CISC процессор необязательно нуждается в микрокоде, но, как правило, подразумевает его наличие.
![image](https://github.com/user-attachments/assets/dfef9295-5e10-4c20-bb4e-d61195965884)

## Microcode

Микроко́д — программа, реализующая набор инструкций процессора. Так же, как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в процессоре, использующем микрокод, каждая машинная инструкция реализуется в виде серии микроинструкций — микропрограммы, микрокода. В проектировании процессоров микрокод служит промежуточным слоем, расположенным между аппаратным обеспечением центрального процессора (CPU) и видимой программисту архитектурой набора инструкций компьютера, также известной как машинный код.

Микрокод хранится в ROM-памяти (Read-Only Memory, только для чтения), которая значительно дешевле оперативной памяти. Следовательно, уменьшение использования оперативной памяти через увеличение использования постоянной памяти — выгодный компромисс.

Микрокод, размещённый в специальной высокоскоростной памяти, преобразует машинные инструкции, данные конечных автоматов или другие входные данные в последовательности детализированных операций на уровне схем. Он отделяет машинные инструкции от базовой электроники, обеспечивая тем самым большую гибкость в проектировании и изменении инструкций. Кроме того, микрокод облегчает реализацию сложных многошаговых инструкций, одновременно снижая сложность компьютерных схем. Процесс написания микрокода часто называют микропрограммированием, а сам микрокод в конкретной реализации процессора иногда называют микропрограммой.

Основная идея микрокода заключается в замене специализированной аппаратной логики, реализующей последовательность выполнения инструкций, серией простых инструкций, выполняемых в так называемом "движке микрокода", встроенном в процессор. В то время как специализированная логическая система может состоять из диодов и логических элементов, подающих определённые напряжения на различные управляющие линии, движок микрокода подключается к этим линиям и включает или отключает их по мере последовательного чтения инструкций микрокода. Инструкции микрокода часто кодируются по битам в соответствии с этими линиями: например, если бит 8 установлен в единицу, это может означать, что арифметико-логическое устройство (ALU) должно приостановиться в ожидании данных. В этом смысле микрокод чем-то напоминает перфорированные рулоны в механическом пианино, где отверстия обозначают, какую клавишу следует нажать.

Первые процессоры могли быть реализованы полностью на аппаратном уровне. Основным инструментом программирования являлся ассемблер --- низкоуровневый язык программирования, непосредственно отображаемый на систему команд процессора. У разработчиков был запрос на:

+ высокую производительность;
+ удобство программирования.

Традиционный на сегодня метод повышения удобства программирования через введение абстракций приводил к:

+ высоким накладным расходам (использование подпрограмм);
+ раздуванию исходного кода (inline).

Поэтому одним из путей улучшения user-experience стало наращивание системы команд с целью естественной реализации всех необходимых инструкций. Причем данное наращивание было связано не только и не столько с добавлением новых арифметических операций, сколько с созданием большого количества типовых команд. К примеру: команды, позволяющие использовать большее количество аргументов или сохранять результат не в регистр, а сразу в память и т.п. Как следствие --- для множества команд нет необходимости добавлять новую логику в процессор (шины данных, регистры, сигнальные линии), необходимо только специфическим образом использовать уже имеющуюся.

![image](https://github.com/user-attachments/assets/f704fdda-cc5a-4af7-a52e-a45a44fde78e)

Инструкции прибывают из памяти, обычно из высокоскоростного кеша. Далее они входят в декодер, который разбивает каждую инструкцию на одну или несколько микроопераций. Хотя они выполняют меньше одной инструкции, они значительно больше.
Следствие --- необходимость "программирования" системы команд процессоров, что вылилось в понятие микрокода --- программы, реализующей набор инструкций процессора. К примеру (Wikipedia):

+ Подсоединить регистр 1 ко входу A АЛУ;
+ Подсоединить регистр 7 ко входу B АЛУ;
+ Настроить АЛУ на выполнение операции сложения;
+ Установить разряд переноса АЛУ в ноль;
+ Сохранить результат операции в регистр 8;
+ Обновить коды состояния из флагов АЛУ («Отрицательное», «Ноль», «Переполнение», «Перенос»);
+ Установить указатель микрокоманд на микроинструкцию номер nnn.

Первоначально микрокод был использован в качестве более простого способа разработки управляющего устройства процессора. Прежде набор инструкций задавался жёстко, каждая машинная инструкция (сложение, сдвиг, копирование) реализовывалась непосредственно в схеме. Это давало высокую скорость, но по мере того, как набор инструкций рос, всё сложнее становилось реализовывать в виде схемы и отлаживать инструкции всё возрастающей сложности. Микрокод смягчил эту проблему тем, что позволил инженерам-проектировщикам при реализации сложной инструкции заменить создание сложной схемы на написание микропрограммы. Более того, микрокод можно было с лёгкостью изменить на поздних этапах проектирования, схему же изменить намного сложнее. Таким образом, микрокод облегчил проектирование процессоров, что привело к усложнению набора команд.

Примечания:

+ Как продать свой процессор? Нужно показать классный код на ассемблере.
+ Xerox Alto - один из знаковых компьютеров, предоставляющий программисту уровень микропрограммирования. Тот самый компьютер от Xerox wiki, Alto: A personal computer.

## NISC

Каким образом можно дальше упростить RISC-процессор? Самое простое и неочевидное решение --- угроза из-за его системной команды, как такая, обеспечившая на уровне машинного кода прямой доступ к сигналам и элементам процессора.

No instruction set computing (NISC) - это вычислительная архитектура и технология компиляции для проектирования высокоэффективных специализированных процессоров и аппаратных ускорителей, позволяющая компилятору осуществлять низкоуровневый контроль над аппаратными ресурсами. NISC (No Instruction Set Computer) не использует заранее определённый набор команд или микрокод. Компилятор генерирует нанокоды для непосредственного управления набором команд или микрокодом.

![image](https://github.com/user-attachments/assets/0132f08e-c08b-428a-873d-ac8af08ba029)

Что это позволяет сделать:

+ ISA как уровень абстракции и фактически достигает того уровня контроля за процессором, который есть в микрокоде (фактически получается программа микропрограммы, единая на всем алгоритме), что позволяет сократить количество команд (не по объему, так как из-за большого количества сигналов, как правило, программа становится больше по объему) и накладные расходы на их выполнение;
значительно упрощенный процессор, оставив в нем только те элементы, которые необходимы для вычислительных задач, перенеся, все, что возможно, в компилятор;
+ упрощение разработки процессоров, так как ограничивается сложный и трудоемкий этап проектирования ISA, но в то же время и проявляется крест на бинарной совместимости между различными процессорами (что некритично для систем на кристалле, а также для специализированного под задаче оборудования);
+ Простое определение процессора устройства позволяет сравнительно легко снизить сам процессор под задачу (допустимо для ПЛИС), а также этим обусловлено применение данной структуры в рамках [высокоуровневого синтеза](https://www.youtube.com/watch?v=mbheV9V8AbM) [( слайды )](https://drive.google.com/file/d/161Lj0fVLHgSYLQMaz0Sn_3TaYUGWYvNI/view).

## Стековые процессоры
