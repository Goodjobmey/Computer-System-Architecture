# [Конспект лекции №8](https://www.youtube.com/watch?v=Iko9CJl2MwQ)

## ISA Overview

Как вы можете представить, количество инструкций, которые понимает процессор, ограничено. Если вы знакомы с программированием, вы знаете, что можно определять собственные функции. Так вот, машинные команды не имеют такой возможности.

Существует фиксированное количество команд, которые понимает процессор. И вы как программист не можете его расширить.

В мире представлено множество различных микропроцессоров, и они не используют одинаковый набор команд. Иными словами, они интерпретируют числа в инструкции по-разному.

Одна архитектура микропроцессора трактует число 501012 как add r10, r12, а другая архитектура --- как load r10, 12. Комбинация инструкций, которые понимает процессор, и регистров, которые ему доступны, называется архитектурой набора команды (Instruction Set Architecture, ISA).

Instruction Set Architecture (ISA) --- это набор команд микропроцессора и система правил, по которым эти команды интерпретируются и выполняются. В общем смысле, ISA служит интерфейсом между аппаратурой компьютера и программным обеспечением.

ISA определяет доступные команды процессора, их формат, регистры, типы данных, режимы адресации, а также способы управления потоками данных и выполнением команд.

Система команд процессора: (Instruction Set Architecture --- ISA) абстрактная модель процессора, формирующая интерфейс взаимодействия между программным обеспечением и процессором.
Производительность, энергопотребление и задержки часто не рассматриваются.

Машинное слово: фрагмент данных фиксированного размера, обрабатываемый как единое целое процессором.
- типы данных,
- модель памяти, система и методы адресации,
- набор инструкций,
- механизмы обработки прерываний и исключений,
- методы ввода и вывода.

![image](https://gitlab.se.ifmo.ru/computer-systems/csa-rolling/-/raw/master/fig/isa-as-interface.png)


### Аккумуляторная архитектура

> Аккумуляторная архитектура возникла одной из первых, потому очень проста. В ней для хранения одного из операндов арифметической или логической операции в процессоре имеется выделенный регистр --- аккумулятор. В этот же регистр заносится и результат операции. Изначально оба операнда хранятся в основной памяти,и до выполнения операции один из них нужно загрузить в аккумулятор. После выполнения команды обработки результат находится в аккумуляторе и, если он не является операндом для последующей команды, его требуется сохранить в ячейке памяти.

Основные компоненты такой архитектуры включают:

- **Память** — для считывания и записи данных;
- **АЛУ** (арифметико-логическое устройство) — для выполнения операций;
- **Аккумулятор** — специальная ячейка памяти, в которую можно многократно накапливать значения, изменяя их на основе ранее сохранённых данных.

#### Пример выполнения вычислений

В качестве примера рассматривается реализация классической линейной функции: 

A = B + (C × D)


Процесс вычисления в аккумуляторной архитектуре выглядит следующим образом:

1. Инициализация аккумулятора значением переменной **C**.
2. Умножение содержимого аккумулятора на значение переменной **D**.
3. Прибавление к аккумулятору значения переменной **B**.
4. Сохранение конечного результата в адрес памяти, соответствующий переменной **A**.

Таким образом, весь вычислительный процесс строится вокруг последовательной работы с аккумулятором через простые шаги.

#### Преимущества аккумуляторной архитектуры

- **Простота системы команд**  
  Архитектура подразумевает минимальный набор инструкций: аккумулятор (неявный аргумент) и адрес памяти (явный аргумент).

- **Компактность инструкций**  
  Инструкции имеют фиксированный размер и малый объём.

- **Простота аппаратной реализации**  
  Реализация процессора становится крайне простой; основная сложность заключается лишь в организации работы с памятью.

#### Ограничения аккумуляторной архитектуры

Одним из ограничений является необходимость частой работы с памятью.  
Например, если бы в формуле использовалось другое действие, например:

A = (B × C) × D


то для хранения промежуточного результата понадобилась бы дополнительная ячейка памяти, так как аккумулятор смог бы удержать только одно промежуточное значение.

![image](https://gitlab.se.ifmo.ru/computer-systems/csa-rolling/-/blob/master/fig/proc-accum-arch.png)

### Регистровая архитектура

Данная архитектура является логическим продолжением аккумуляторной и особо не отличается, заисключением того, что теперь заместо одного аккумулятора у нас будет много регистров.

Микропроцессор с архитектурой данного типа включает в себя массив регистров, известных как регистры общего назначения. В микропроцессоре отсутствует специальный регистр данных, выполняющий функции аккумулятора. Функции аккумулятора выполняет один из регистров общего назначения.

Размер регистров обычно фиксирован и совпадает с размером машинного слова.К любому регистру можно обратиться,указав его номер. Регистровая архитектура допускает расположение операндов в одном из двух пространств: основной памяти или регистрах. С учетом возможного размещения операндов в рамках регистровых архитектур выделяют три типа команд обработки: Register-to-Register, Register-to-Memory, Memory-to-Memory.

| Тип | Достоинства | Недостатки |
|----------|----------|----------|
| Register-to-Memory    | Данные могут быть доступны без загрузки в регистры процессора; простота кодирования команд; объектный код получается достаточно компактным   | Потеря одного из операндов при записи результата; длинное поле адреса памяти в коде команды сокращает место под номер регистра, что ограничивает общее число РОН. Количество тактов процессора, приходящихся на одну команду (CPI), зависит от места размещения операнда   |
| Register-to-Register    | Простота реализации; фиксиро­ванная длина команд; простая модель формирования объект­ного кода при компиляции программ; возможность выполне­ния всех команд за одинаковое количество тактов   | Большая длина объектного кода; из-за фиксированной длины команд часть разрядов в коротких командах не используется   |
| Memory-to-Memory    | Компактность объектного кода, малая потребность в регистрах для хранения промежуточных данных   | Разнообразие форматов команд и времени их исполнения, низкое быстродействие из-за обращения к памяти   |

#### Register-to-Memory

В архитектуре Register-to-Memory один из операндов для операций, таких как сложение (ADD), может находиться в памяти, в то время как другой — в регистре.

![image](https://github.com/user-attachments/assets/b8bddab3-d0bc-420d-a86d-b8c306bf171e)
#### Register-to-Register
![image](https://github.com/user-attachments/assets/3a0a9c2f-3f3a-40a9-aa31-ae3f3586ed6b)
#### Memory-to-Memory
![image](https://github.com/user-attachments/assets/558199b1-316e-4727-aad2-ca919c05520a)
### Стековая архитектура

Среди других типов архитектур выделяется стековая архитектура. В её основе лежит принцип использования стековой памяти, размещённой непосредственно внутри процессора, вместо традиционного набора регистров. Стек представляет собой совокупность связанных между собой ячеек памяти, функционирующих по принципу «последним вошёл --- первым вышел» (LIFO, Last In First Out), что позволяет обращаться исключительно к элементу, находящемуся на вершине стека. Соответственно, в стековой архитектуре аргументы явно не указываются, а используются данные, размещённые на вершине стека.

**Преимущества стековой архитектуры**:
1. **Естественная поддержка процедур**. Аргументы функций передаются посредством стека без необходимости использования ограниченного числа регистров, что особенно актуально при глубокой вложенности вызовов. Это избавляет от необходимости введения соглашений об использовании регистров --- все необходимые данные просто помещаются в стек.
2. **Простота реализации**. Стековая архитектура характеризуется простотой реализации и минималистичным машинным кодом, что упрощает проектирование процессоров.

**Недостатки стековой архитектуры**:
1. **Неудобство произвольного доступа**. В случае необходимости обращения к элементам стека, расположенным не на вершине, возникает необходимость выполнения дополнительных операций, что приводит к увеличению количества команд. Для частичного решения этой проблемы могут использоваться несколько стеков или дополнительные регистры.
2. **Сложности в оптимизации**. Ограничение работы только с вершиной стека затрудняет распараллеливание операций, что снижает производительность и ограничивает возможности ускорения выполнения программ.

Стековые процессоры часто применяются в реализации интерпретаторов, поскольку построение виртуальных машин на основе стека является удобным и эффективным решением.

![image](https://github.com/user-attachments/assets/43be07b5-7655-40ab-aba3-b935a9dea4d2)

## Машина фон-Неймана

Машина фон Неймана представляет собой абстрактную модель вычислительной системы, поскольку многие элементы её архитектуры изначально не были конкретизированы. Это сделано намеренно, чтобы не ограничивать творческий подход инженеров-разработчиков при создании новых ЭВМ. Таким образом, архитектура машины фон Неймана описана не на уровне внутренней реализации, а на концептуальном уровне представления вычислительного процесса.

Рассмотрим более конкретную организацию архитектуры фон Неймана:

![image](https://gitlab.se.ifmo.ru/computer-systems/csa-rolling/-/raw/master/fig/von-neumann-example.png)

Описание:

- Разрядность процессора: 8 бит.
- Организация памяти: гарвардская, с отдельными блоками памяти для команд и данных.
- Внешние устройства (для данной работы это светодиоды, двухпозиционные переключатели и тактовые кнопки) отображаются в адресное пространство данных. Работа с ними выполняется по опросу.
- Регистры:
    - `PC` --- регистр счётчика команд (Program Counter) указывает адрес текущей инструкции, при этом общее количество возможных инструкций составляет 256.
    - `IR` --- регистр инструкций (Instruction Register), предназначен для хранения активной команды или операционного кода, поступающего из памяти команд.
    - `AR` --- регистр адреса операнда (Address Register) содержит адрес памяти, который будет использован в следующих тактах.
    - `C` --- флаг переноса/заёма
    - `Z` --- флаг нуля
- Команды выполняются за 2 или 3 такта (в зависимости от типа команды):
    1. Выборка команды
    2. Выборка операндов
    3. Выполнение команды.
- Подсистема обработки прерываний и команды вызова подпрограмм отсутствует.
- В архитектуре предусмотрен мультиплексор (MUX2), который позволяет выбирать источник данных для левого входа арифметико-логического устройства (АЛУ): либо данные из памяти данных, либо данные из памяти команд. Второй аргумент для АЛУ поступает исключительно из аккумулятора, в который затем записывается результат вычислений.

[Пример модели процессора на Haskell](http://amazing-new-gate.blogspot.com/2010/07/haskell.html)

## Complex Instruction Set Computer

**CISC (Complex Instruction Set Computing)** — архитектура процессора с полным набором команд, в которой отдельные инструкции способны выполнять несколько операций низкого уровня (например, загрузку из памяти, арифметические вычисления и сохранение обратно в память) или многошаговые процедуры в рамках одной инструкции. Основоположником CISC-архитектуры считается компания IBM с архитектурой IBM/360. Типичными примерами CISC-процессоров являются x86, Motorola MC680x0, Zilog Z80 и мейнфреймы серии zSeries.

Основная идея CISC заключалась в стремлении обеспечить максимально эффективное управление процессором. Для этого систему команд усложнили, чтобы минимизировать количество лишних операций при выполнении задач. Архитектура стремилась к тому, чтобы каждая типовая операция обработки данных имела свою специализированную машинную команду. Это позволило упростить процесс программирования на низкоуровневых языках и существенно сократить объем разрабатываемого кода.

Одним из факторов, способствовавших развитию CISC, стало внедрение микропрограммного управления. Микропрограммы позволяли сравнительно просто формировать сложные команды и расширенные режимы адресации без значительных затрат на аппаратную реализацию. Благодаря этому стало возможным:
- поддерживать различные режимы адресации для всех типов команд;
- реализовывать сложные арифметические операции в рамках одной инструкции;
- создавать потоковые операции обработки данных.

Микропрограммное управление также обеспечивало возможность обновления и оптимизации работы процессора после его выпуска за счёт изменения микрокода, как это было реализовано, например, в системах семейства УВК «Самсон» для РВСН.


**Причины появления архитектуры CISC**
- **Низкоуровневые языки:** На момент появления CISC-процессоров высокоуровневые языки ещё не получили широкого распространения. Программирование велось преимущественно на ассемблере, и наличие расширенного набора команд облегчало написание кода.
- **Разнообразие архитектур:** Существенные различия между архитектурами затрудняли переносимость программ. Универсальные и мощные команды помогали нивелировать эти различия.
- **Неразвитость компиляторов:** Ограниченные возможности компиляторов вынуждали перекладывать задачи оптимизации программ на процессоры с расширенным набором инструкций.
- **Удобство программирования:** Большое количество мощных команд позволяло уменьшить объём кода и упростить его разработку.
- **Высокая производительность:** Многофункциональные инструкции обеспечивали выполнение сложных операций за один цикл программной логики, повышая эффективность без дополнительных оптимизаций.
- **Минимизация объёма программ:** Компактные инструкции позволяли экономить дефицитные ресурсы памяти.
- **Минимизация накладных расходов:** Уменьшение количества обращений к памяти и внутренних пересылок данных снижало накладные затраты при выполнении программ.


**Преимущества архитектуры CISC**
- Удобство использования ассемблера для написания программ.
- Снижение затрат на доступ к памяти команд благодаря более коротким программам.
- Возможность обновления микрокода для улучшения функциональности процессора.
- Возможность оптимизации микрокода для конкретных алгоритмов, сокращение объема программ и устранение лишних операций.


**Проблемы архитектуры CISC**
- **Сложность системы команд:** Большое количество команд делает их полное освоение и эффективное использование сложной задачей для программистов и компиляторов.
- **Усложнение устройства процессора и блока управления:** Наличие множества инструкций, способов адресации и аргументов приводит к значительному усложнению схем управления процессором.
- **Сложность генерации эффективного машинного кода:** Автоматические компиляторы испытывают трудности в создании оптимального кода для CISC-процессоров.
- **Высокая стоимость хранения микрокода:** Микропрограммы требуют размещения в быстрой внутренней памяти процессора, что увеличивает стоимость чипа.
- **Повышенные требования к разработчикам:** Разработка и сопровождение сложных систем команд требуют глубоких знаний архитектуры процессора.
- **Сложности оптимизации производительности:** Большое разнообразие команд и их неоднородность затрудняют реализацию высокоэффективных методов обработки, таких как конвейеризация и суперскалярность.
- **Высокая стоимость разработки микрокода:** Программирование микрокода требует значительных затрат на отладку и оптимизацию.

Несмотря на выявленные недостатки, архитектура CISC продолжает активно использоваться ведущими производителями процессоров (Intel, AMD, IBM). В современных CISC-процессорах применяются гибридные подходы, сочетающие принципы CISC и RISC для достижения максимальной производительности.

![image](https://github.com/user-attachments/assets/dfef9295-5e10-4c20-bb4e-d61195965884)

## Microcode

Что нам стоит ставить на первое место в проектировании CISC процессоров, понятное дело, что с точки зрения аппаратуры и и того, как оно работает под капотом? Это второй пункт: устройство Control Unit, потому что сделать в аппаратуре конечный автомат, который будет генерировать все это многообразие инструкций невероятно сложно. 

Eсть два подхода к реализации Control Unit:
- **Hardwired**. При помощи аппаратных комбинационных схем, декодирующих инструкции в последовательности сигналов. Этот блок управления использует фиксированный набор логических вентилей и схем для выполнения инструкций. Управляющие сигналы для каждой инструкции жестко подключены к блоку управления, поэтому блок управления имеет специальную схему для каждой возможной инструкции. Hardwired control units просты и быстры, но они могут быть негибкими и сложными для модификации.
- **Microcoded**. При помощи исполнения микропрограммы, реализующей необходимые функции. Это значит, что внутри процессора будет лежать память, которая должна быть очень быстрой, ведь мы будем обращаться к ней очень много раз в течение каждой инструкции, и которая будет управлять всем алгоритмом внутри процессора.

**Микропрограмма** (микрокод) - программа, реализующая набор инструкций процессора. Так же как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в процессоре, использующем микрокод, каждая машинная инструкция реализуется в виде серии микроинструкций — микропрограммы, микрокода.


Микроко́д — программа, реализующая набор инструкций процессора. Так же, как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в процессоре, использующем микрокод, каждая машинная инструкция реализуется в виде серии микроинструкций — микропрограммы, микрокода. В проектировании процессоров микрокод служит промежуточным слоем, расположенным между аппаратным обеспечением центрального процессора (CPU) и видимой программисту архитектурой набора инструкций компьютера, также известной как машинный код.

Микрокод хранится в ROM-памяти (Read-Only Memory, только для чтения), которая значительно дешевле оперативной памяти. Следовательно, уменьшение использования оперативной памяти через увеличение использования постоянной памяти — выгодный компромисс.

Микрокод, размещённый в специальной высокоскоростной памяти, преобразует машинные инструкции, данные конечных автоматов или другие входные данные в последовательности детализированных операций на уровне схем. Он отделяет машинные инструкции от базовой электроники, обеспечивая тем самым большую гибкость в проектировании и изменении инструкций. Кроме того, микрокод облегчает реализацию сложных многошаговых инструкций, одновременно снижая сложность компьютерных схем. Процесс написания микрокода часто называют микропрограммированием, а сам микрокод в конкретной реализации процессора иногда называют микропрограммой.

Основная идея микрокода заключается в замене специализированной аппаратной логики, реализующей последовательность выполнения инструкций, серией простых инструкций, выполняемых в так называемом "движке микрокода", встроенном в процессор. В то время как специализированная логическая система может состоять из диодов и логических элементов, подающих определённые напряжения на различные управляющие линии, движок микрокода подключается к этим линиям и включает или отключает их по мере последовательного чтения инструкций микрокода. Инструкции микрокода часто кодируются по битам в соответствии с этими линиями: например, если бит 8 установлен в единицу, это может означать, что арифметико-логическое устройство (ALU) должно приостановиться в ожидании данных. В этом смысле микрокод чем-то напоминает перфорированные рулоны в механическом пианино, где отверстия обозначают, какую клавишу следует нажать.

Первые процессоры могли быть реализованы полностью на аппаратном уровне. Основным инструментом программирования являлся ассемблер --- низкоуровневый язык программирования, непосредственно отображаемый на систему команд процессора. У разработчиков был запрос на:

+ высокую производительность;
+ удобство программирования.

Традиционный на сегодня метод повышения удобства программирования через введение абстракций приводил к:

+ высоким накладным расходам (использование подпрограмм);
+ раздуванию исходного кода (inline).

Поэтому одним из путей улучшения user-experience стало наращивание системы команд с целью естественной реализации всех необходимых инструкций. Причем данное наращивание было связано не только и не столько с добавлением новых арифметических операций, сколько с созданием большого количества типовых команд. К примеру: команды, позволяющие использовать большее количество аргументов или сохранять результат не в регистр, а сразу в память и т.п. Как следствие --- для множества команд нет необходимости добавлять новую логику в процессор (шины данных, регистры, сигнальные линии), необходимо только специфическим образом использовать уже имеющуюся.

![image](https://github.com/user-attachments/assets/f704fdda-cc5a-4af7-a52e-a45a44fde78e)

Инструкции прибывают из памяти, обычно из высокоскоростного кеша. Далее они входят в декодер, который разбивает каждую инструкцию на одну или несколько микроопераций. Хотя они выполняют меньше одной инструкции, они значительно больше.
Следствие --- необходимость "программирования" системы команд процессоров, что вылилось в понятие микрокода --- программы, реализующей набор инструкций процессора. К примеру (Wikipedia):

+ Подсоединить регистр 1 ко входу A АЛУ;
+ Подсоединить регистр 7 ко входу B АЛУ;
+ Настроить АЛУ на выполнение операции сложения;
+ Установить разряд переноса АЛУ в ноль;
+ Сохранить результат операции в регистр 8;
+ Обновить коды состояния из флагов АЛУ («Отрицательное», «Ноль», «Переполнение», «Перенос»);
+ Установить указатель микрокоманд на микроинструкцию номер nnn.

Первоначально микрокод был использован в качестве более простого способа разработки управляющего устройства процессора. Прежде набор инструкций задавался жёстко, каждая машинная инструкция (сложение, сдвиг, копирование) реализовывалась непосредственно в схеме. Это давало высокую скорость, но по мере того, как набор инструкций рос, всё сложнее становилось реализовывать в виде схемы и отлаживать инструкции всё возрастающей сложности. Микрокод смягчил эту проблему тем, что позволил инженерам-проектировщикам при реализации сложной инструкции заменить создание сложной схемы на написание микропрограммы. Более того, микрокод можно было с лёгкостью изменить на поздних этапах проектирования, схему же изменить намного сложнее. Таким образом, микрокод облегчил проектирование процессоров, что привело к усложнению набора команд.

Примечания:

+ Как продать свой процессор? Нужно показать классный код на ассемблере.
+ Xerox Alto - один из знаковых компьютеров, предоставляющий программисту уровень микропрограммирования. Тот самый компьютер от Xerox wiki, Alto: A personal computer.

## NISC

Каким образом можно дальше упростить RISC-процессор? Самое простое и неочевидное решение --- угроза из-за его системной команды, как такая, обеспечившая на уровне машинного кода прямой доступ к сигналам и элементам процессора.

No instruction set computing (NISC) - это вычислительная архитектура и технология компиляции для проектирования высокоэффективных специализированных процессоров и аппаратных ускорителей, позволяющая компилятору осуществлять низкоуровневый контроль над аппаратными ресурсами. NISC (No Instruction Set Computer) не использует заранее определённый набор команд или микрокод. Компилятор генерирует нанокоды для непосредственного управления набором команд или микрокодом.

![image](https://github.com/user-attachments/assets/0132f08e-c08b-428a-873d-ac8af08ba029)

Что это позволяет сделать:

+ ISA как уровень абстракции и фактически достигает того уровня контроля за процессором, который есть в микрокоде (фактически получается программа микропрограммы, единая на всем алгоритме), что позволяет сократить количество команд (не по объему, так как из-за большого количества сигналов, как правило, программа становится больше по объему) и накладные расходы на их выполнение;
значительно упрощенный процессор, оставив в нем только те элементы, которые необходимы для вычислительных задач, перенеся, все, что возможно, в компилятор;
+ упрощение разработки процессоров, так как ограничивается сложный и трудоемкий этап проектирования ISA, но в то же время и проявляется крест на бинарной совместимости между различными процессорами (что некритично для систем на кристалле, а также для специализированного под задаче оборудования);
+ Простое определение процессора устройства позволяет сравнительно легко снизить сам процессор под задачу (допустимо для ПЛИС), а также этим обусловлено применение данной структуры в рамках [высокоуровневого синтеза](https://www.youtube.com/watch?v=mbheV9V8AbM) [( слайды )](https://drive.google.com/file/d/161Lj0fVLHgSYLQMaz0Sn_3TaYUGWYvNI/view).

