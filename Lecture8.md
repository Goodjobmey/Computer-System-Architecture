# [Конспект лекции №8](https://www.youtube.com/watch?v=Iko9CJl2MwQ)

## ISA Overview
### Аккумуляторная архитектура

Аккумуляторная архитектура возникла одной из первых и к тому же очень проста. В ней для хранения одного из операндов арифметической или логической операции в процессоре имеется выделенный регистр — аккумулятор. В этот же регистр заносится и результат операции. Изначально оба операнда хранятся в основной памяти,и до выполнения операции один из них нужно загрузить в аккумулятор. После выполнения команды обработки результат находится в аккумуляторе и, если он не является операндом для последующей команды, его требуется сохранить в ячейке памяти.

![image](https://github.com/user-attachments/assets/3b4bf477-2050-4816-adf1-e7e12b9750e3)
### Регистровая архитектура

Данная архитектура является логическим продолжением аккумуляторной и особо не отличается, заисключением того, что теперь заместо одного аккумулятора у нас будет много регистров.

Микропроцессор с архитектурой данного типа включает в себя массив регистров, известных как регистры общего назначения. В микропроцессоре отсутствует специальный регистр данных, выполняющий функции аккумулятора. Функции аккумулятора выполняет один из регистров общего назначения.

Размер регистров обычно фиксирован и совпадает с размером машинного слова.К любому регистру можно обратиться,указав его номер. Регистровая архитектура допускает расположение операндов в одном из двух пространств: основной памяти или регистрах. С учетом возможного размещения операндов в рамках регистровых архитектур выделяют три типа команд обработки: Register-to-Register, Register-to-Memory, Memory-to-Memory.

#### Register-to-Memory
![image](https://github.com/user-attachments/assets/b8bddab3-d0bc-420d-a86d-b8c306bf171e)
#### Register-to-Register
![image](https://github.com/user-attachments/assets/3a0a9c2f-3f3a-40a9-aa31-ae3f3586ed6b)
#### Memory-to-Memory
![image](https://github.com/user-attachments/assets/558199b1-316e-4727-aad2-ca919c05520a)
### Стековая архитектура
![image](https://github.com/user-attachments/assets/43be07b5-7655-40ab-aba3-b935a9dea4d2)

## Процессор фон-Неймана

## Complex Instruction Set Computer
CISC - это компьютерная архитектура, в которой отдельные инструкции могут выполнять несколько операций низкого уровня (загрузка из памяти, арифметическая операция и сохранение в памяти) или способны выполнять многошаговые операции или режимы адресации в рамках отдельных инструкций.

Архитектура CISC в значительной степени стала возможна благодаря возможностям микропрограммного управления. Микропрограмма позволяет относительно легко (по сравнению с разработкой аппаратуры) формировать большое количество команд со сложным поведением. Поднять уровень машинных инструкций ближе к уровню языков программирования высокого уровня. К примеру:

+ относительно легко поддержать все интересующие варианты адресаций для всех типов команд;
+ реализовать операции с произвольным набором аргументов, к примеру, инструкцию для расчета многочленов в рамках одной инструкции;
+ реализовать операции, работающие в потоковом режиме.

Основными преимуществами такого подхода являются:

+ удобство использования ассемблера как инструмента программирования;
+ сокращение затрат на доступ к памяти команд, так как гибкость позволяет сократить количество инструкций;
+ возможность обновления микропрограммного управления позволяет обновить "прошивку" процессора, и тем самым улучшить его функциональность уже после производства аппаратуры;
  + Существуют семейства процессоров и инструментальных средств для них, активно эксплуатирующие данную возможность, к примеру: УВК «Самсон» – базовая ЭВМ РВСН. Оптимизация микрокода под конкретный алгоритм позволяет сократить объём программ (машинное представление), а также оптимизировать лишние операции.

Но также он сопряжён с рядом недостатков:

+ Необходимо хранить микрокод непосредственно в процессоре (необходим мгновенный доступ к нему), где хранение данных --- весьма дорогой процесс, по сравнению с внешней памятью. Чем сложнее система команд, тем больше необходимо памяти.
+ Развитый ассемблер требует большого объёма знаний о процессоре от разработчика. Кроме того, лёгкость развития и модернизации системы команд провоцирует рост разнообразия процессорных архитектур, что, в свою очередь, накладывает серьёзные требования на инструментальные средства.
+ Наличие большого количества программного обеспечения (пусть и в виде микрокода) сопряжено со всеми сложностями программирования. В данном случае это означает, что программное обеспечение нуждается в дорогостоящей отладке и оптимизации, что значительно повышает стоимость разработки.
+ Большое разнообразие команд делает их относительно уникальными с точки зрения формата, размера команды, длительности исполнения и количества доступов к памяти. Как следствие это усложняет:

  + реализацию оптимизаций в рамках процессора (конвейерное исполнение, суперскалярность и т.п.);
  + поддержку со стороны инструментальных средств (компиляторы, дизассемблеры, отладчики и т.п.), в качестве примера можно посмотреть о сложностях разработки дизассемблеров для современных процессоров x86.

Примечание: CISC процессор необязательно нуждается в микрокоде, но, как правило, подразумевает его наличие.
![image](https://github.com/user-attachments/assets/dfef9295-5e10-4c20-bb4e-d61195965884)

## Microcode
Первые процессоры могли быть реализованы полностью на аппаратном уровне. Основным инструментом программирования являлся ассемблер --- низкоуровневый язык программирования, непосредственно отображаемый на систему команд процессора. У разработчиков был запрос на:

+ высокую производительность;
+ удобство программирования.

Традиционный на сегодня метод повышения удобства программирования через введение абстракций приводил к:

+ высоким накладным расходам (использование подпрограмм);
+ раздуванию исходного кода (inline).

Поэтому одним из путей улучшения user-experience стало наращивание системы команд с целью естественной реализации всех необходимых инструкций. Причем данное наращивание было связано не только и не столько с добавлением новых арифметических операций, сколько с созданием большого количества типовых команд. К примеру: команды, позволяющие использовать большее количество аргументов или сохранять результат не в регистр, а сразу в память и т.п. Как следствие --- для множества команд нет необходимости добавлять новую логику в процессор (шины данных, регистры, сигнальные линии), необходимо только специфическим образом использовать уже имеющуюся.
![image](https://github.com/user-attachments/assets/f704fdda-cc5a-4af7-a52e-a45a44fde78e)
Инструкции прибывают из памяти, обычно из высокоскоростного кеша. Далее они входят в декодер, который разбивает каждую инструкцию на одну или несколько микроопераций. Хотя они выполняют меньше одной инструкции, они значительно больше.
Следствие --- необходимость "программирования" системы команд процессоров, что вылилось в понятие микрокода --- программы, реализующей набор инструкций процессора. К примеру (Wikipedia):

+ Подсоединить регистр 1 ко входу A АЛУ;
+ Подсоединить регистр 7 ко входу B АЛУ;
+ Настроить АЛУ на выполнение операции сложения;
+ Установить разряд переноса АЛУ в ноль;
+ Сохранить результат операции в регистр 8;
+ Обновить коды состояния из флагов АЛУ («Отрицательное», «Ноль», «Переполнение», «Перенос»);
+ Установить указатель микрокоманд на микроинструкцию номер nnn.

Примечания:

+ Как продать свой процессор? Нужно показать классный код на ассемблере.
+ Xerox Alto - один из знаковых компьютеров, предоставляющий программисту уровень микропрограммирования. Тот самый компьютер от Xerox wiki, Alto: A personal computer.

## NISC

Каким образом можно дальше упростить RISC-процессор? Самое простое и неочевидное решение --- угроза из-за его системной команды, как такая, обеспечившая на уровне машинного кода прямой доступ к сигналам и элементам процессора.

No instruction set computing (NISC) - это вычислительная архитектура и технология компиляции для проектирования высокоэффективных специализированных процессоров и аппаратных ускорителей, позволяющая компилятору осуществлять низкоуровневый контроль над аппаратными ресурсами.

![image](https://github.com/user-attachments/assets/0132f08e-c08b-428a-873d-ac8af08ba029)

Что это позволяет сделать:

+ ISA как уровень абстракции и фактически достигает того уровня контроля за процессором, который есть в микрокоде (фактически получается программа микропрограммы, единая на всем алгоритме), что позволяет сократить количество команд (не по объему, так как из-за большого количества сигналов, как правило, программа становится больше по объему) и накладные расходы на их выполнение;
значительно упрощенный процессор, оставив в нем только те элементы, которые необходимы для вычислительных задач, перенеся, все, что возможно, в компилятор;
+ упрощение разработки процессоров, так как ограничивается сложный и трудоемкий этап проектирования ISA, но в то же время и проявляется крест на бинарной совместимости между различными процессорами (что некритично для систем на кристалле, а также для специализированного под задаче оборудования);
+ Простое определение процессора устройства позволяет сравнительно легко снизить сам процессор под задачу (допустимо для ПЛИС), а также этим обусловлено применение данной структуры в рамках [высокоуровневого синтеза](https://www.youtube.com/watch?v=mbheV9V8AbM) [( слайды )](https://drive.google.com/file/d/161Lj0fVLHgSYLQMaz0Sn_3TaYUGWYvNI/view).

## Стековые процессоры
