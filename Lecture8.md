# [Конспект лекции №8](https://www.youtube.com/watch?v=Iko9CJl2MwQ)

## ISA Overview

Как вы можете представить, количество инструкций, которые понимает процессор, ограничено. Если вы знакомы с программированием, вы знаете, что можно определять собственные функции. Так вот, машинные команды не имеют такой возможности.

Существует фиксированное количество команд, которые понимает процессор. И вы как программист не можете его расширить.

В мире представлено множество различных микропроцессоров, и они не используют одинаковый набор команд. Иными словами, они интерпретируют числа в инструкции по-разному.

Одна архитектура микропроцессора трактует число 501012 как add r10, r12, а другая архитектура — как load r10, 12. Комбинация инструкций, которые понимает процессор, и регистров, которые ему доступны, называется архитектурой набора команды (Instruction Set Architecture, ISA).

Instruction Set Architecture (ISA) — это набор команд микропроцессора и система правил, по которым эти команды интерпретируются и выполняются. В общем смысле, ISA служит интерфейсом между аппаратурой компьютера и программным обеспечением.

ISA определяет доступные команды процессора, их формат, регистры, типы данных, режимы адресации, а также способы управления потоками данных и выполнением команд.

Система команд процессора: (Instruction Set Architecture -- ISA) абстрактная модель процессора, формирующая интерфейс взаимодействия между программным обеспечением и процессором.
Производительность, энергопотребление и задержки часто не рассматриваются.

Машинное слово: фрагмент данных фиксированного размера, обрабатываемый как единое целое процессором.
- типы данных,
- модель памяти, система и методы адресации,
- набор инструкций,
- механизмы обработки прерываний и исключений,
- методы ввода и вывода.

![image](https://github.com/user-attachments/assets/c0f296af-4207-4a55-a6b1-bf187fa0c935)
![image](https://gitlab.se.ifmo.ru/computer-systems/csa-rolling/-/raw/master/fig/isa-as-interface.png)


### Аккумуляторная архитектура

Аккумуляторная архитектура возникла одной из первых, потому очень проста. В ней для хранения одного из операндов арифметической или логической операции в процессоре имеется выделенный регистр — аккумулятор. В этот же регистр заносится и результат операции. Изначально оба операнда хранятся в основной памяти,и до выполнения операции один из них нужно загрузить в аккумулятор. После выполнения команды обработки результат находится в аккумуляторе и, если он не является операндом для последующей команды, его требуется сохранить в ячейке памяти.

![image](https://github.com/user-attachments/assets/3b4bf477-2050-4816-adf1-e7e12b9750e3)

### Регистровая архитектура

Данная архитектура является логическим продолжением аккумуляторной и особо не отличается, заисключением того, что теперь заместо одного аккумулятора у нас будет много регистров.

Микропроцессор с архитектурой данного типа включает в себя массив регистров, известных как регистры общего назначения. В микропроцессоре отсутствует специальный регистр данных, выполняющий функции аккумулятора. Функции аккумулятора выполняет один из регистров общего назначения.

Размер регистров обычно фиксирован и совпадает с размером машинного слова.К любому регистру можно обратиться,указав его номер. Регистровая архитектура допускает расположение операндов в одном из двух пространств: основной памяти или регистрах. С учетом возможного размещения операндов в рамках регистровых архитектур выделяют три типа команд обработки: Register-to-Register, Register-to-Memory, Memory-to-Memory.

| Тип | Достоинства | Недостатки |
|----------|----------|----------|
| Register-to-Memory    | Данные могут быть доступны без загрузки в регистры процессора; простота кодирования команд; объектный код получается достаточно компактным   | Потеря одного из операндов при записи результата; длинное поле адреса памяти в коде команды сокращает место под номер регистра, что ограничивает общее число РОН. Количество тактов процессора, приходящихся на одну команду (CPI), зависит от места размещения операнда   |
| Register-to-Register    | Простота реализации; фиксиро­ванная длина команд; простая модель формирования объект­ного кода при компиляции программ; возможность выполне­ния всех команд за одинаковое количество тактов   | Большая длина объектного кода; из-за фиксированной длины команд часть разрядов в коротких командах не используется   |
| Memory-to-Memory    | Компактность объектного кода, малая потребность в регистрах для хранения промежуточных данных   | Разнообразие форматов команд и времени их исполнения, низкое быстродействие из-за обращения к памяти   |

#### Register-to-Memory

В архитектуре Register-to-Memory один из операндов для операций, таких как сложение (ADD), может находиться в памяти, в то время как другой — в регистре.

![image](https://github.com/user-attachments/assets/b8bddab3-d0bc-420d-a86d-b8c306bf171e)
#### Register-to-Register
![image](https://github.com/user-attachments/assets/3a0a9c2f-3f3a-40a9-aa31-ae3f3586ed6b)
#### Memory-to-Memory
![image](https://github.com/user-attachments/assets/558199b1-316e-4727-aad2-ca919c05520a)
### Стековая архитектура

Отдельно от всех стоит стековая архитектура. В ее основе лежит идея, что вместо набора регистров, есть стековая память прямо внутри процессора. Стек образует множество взаимосвязанных ячеек, взаимодействующих по принципу «последним вошел, первым вышел» (LIFO, Last In First Out), то есть мы можем обращаться только к последнему положенному элементу (вершине стека). Отсюда следует и принцип работы стековой архитектуры: мы не упоминаем аргументы, а используем то, что лежит сверху стека. 

Преимущества такого подхода:
1. **Процедуры появляются естесвенным образом**. Мы естественным образом прокидываем внутрь функции все аргументы. Проблемы, которые возникали при вызове большого количества вложенных функций, когда регисторв только 32, просто не возникают. Не нужно продумывать соглашение об использовании регистров. Просто все необходимые данные положим в стек.
2. **Простота реализации**. Эта архитектура проста с точки зрения реализации, и у нее очень простой машинный код. 

Недостатки. 
1. **Неудобство обращения**. Если вдруг нам нужно ходить по стеку каким-то хитрым способом, заставляющим дублировать значения, обращаться на два элемента назад и тому подобное, придется выполнять очень много лишних действий. Чтобы как-то улучшить этот процесс, используется либо несколько стеков в одной машине, либо дополнительные регистры.
2. **Сложно оптимизации**. То, что в других архитектурах можно было бы выполнить параллельно, в стековой придется делать последовательно, потому что мы очень сильно привязаны к тому, что лежит на вершине стека. Поэтому мы очень сильно ограничены с точки зрения производительности и ускорения.

Довольно часто мы можем увидеть стековый процессор внутри реализации какого-нибудь интерпретатора, потому что виртуальные машины на основе стека писать очень удобно.

![image](https://github.com/user-attachments/assets/43be07b5-7655-40ab-aba3-b935a9dea4d2)

## Машина фон-Неймана

![image]()

Машина фон Неймана является абстрактной моделью ЭВМ, и в этом смысле она похожа на абстрактные исполнители алгоритмов, например, на машину Тьюринга, однако между ними есть и существенное различие. Машина Тьюринга может обрабатывать входные слова любой длины, поэтому её принципиально нельзя реализовать. Машина фон Неймана не поддаётся реализации по другой причине: многие детали в архитектуре этого вычислителя не конкретизированы. Это сделано специально, чтобы не сковывать творческого подхода к делу у инженеров-разработчиков новых ЭВМ. Можно сказать, что машина фон Неймана описана не на внутреннем, а только на концептуальном уровне видения архитектуры.
Можно сказать, что в машине фон Неймана зафиксированы те прогрессивные особенности архитектуры, которые в той или иной степени должны были быть присущи всем компьютерам того времени. Разумеется, практически все современные ЭВМ по своей архитектуре в значительной степени отличаются от машины фон Неймана. 

Ключевые отличия:
- лента заменена на Random-Access Memory (RAM);
- инструкции и данные объединены.

Основополагающие свойства архитектуры машины фон Неймана сформулированы в виде принципов фон Неймана:

1. **Принцип линейности и однородности памяти**. В любую ячейку памяти другие устройства машины могут записывать и считывать информацию, причем время чтения из любой ячейки одинаково для всех ячеек памяти. Время записи в любую ячейку тоже одинаково (это и есть _принцип однородности памяти_), время чтения из ячейки памяти, однако, может не совпадать со временем записи в неё. Ячейки памяти в машине фон Неймана нумеруются от нуля до некоторого положительного числа N, это и означает, что память _линейная_, т.е. упорядоченная, за каждой ячейкой (кроме последней) есть следующая, и перед каждой ячейкой (кроме первой) есть предыдущая.
2. **Принцип неразличимости команд и данных**. С точки зрения программиста машинное слово представляет собой либо команду, либо подлежащее обработке данное. Но в данной архитектуре числа и команды неотличимы друг от друга – в памяти и те и другое представляются некоторым набором разрядов, причем по внешнему виду машинного слова нельзя определить, что оно собой представляет – команду или число.
3. **Принцип хранимой программы**. Этот принцип является очень важным, его суть состоит в том, что программа хранится вместе с числами в одной и той же памяти. Чтобы понять важность этого принципа, вспоминим, что команды программы могут вводится в память с помощью устройства ввода (этот способ был основным в первых компьютерах). Также на вход алгоритма можно в качестве входных данных подавать запись некоторого другого алгоритма, ровно как и выходными данными алгоритма тоже может быть запись некоторого алгоритма. Таким образом, одна программа может в качестве результата своей работы поместить в память компьютера другую программу (собственно так работают компиляторы).
4. **Принцип автоматической работы**. Машина, вы- полняя записанную в её памяти программу, функционирует автоматически, без участия человека, если только такое участие не предусмотрено в самой программе (например, при вводе данных).
5. **Принцип последовательного выполнения**. Устройство управления выполняет некоторую команду от начала до конца, а затем по определенному правилу выбирает следующую команду для выполнения, затем следующую и т.д

[курс лекций "Архитектура ЭВМ и язык Ассемблера" факультета Вычислительной математики и кибернетики Московского Государственного университета им. М. В. Ломоносова](http://arch32.cs.msu.su/Text/Chapter_02.pdf)

### Машина фон Неймана. Особенности
1. Использование двоичного кодирования.
    - Встречается троичное и двоично-десятичное кодирование.
1. Программное управление. Команды выполняются последовательно.
    - Последовательность и порядок сегодня условны.
1. Память компьютера однородно хранит данные и программы.
    - Однородность спорна.
1. Ячейки памяти компьютера имеют адреса. Random-Access Memory.
    - Адрес не сводится к целому числу сегодня.
    - Память не является пассивным элементом компьютера.
1. Возможность условного перехода.
    - И перехода по иным причинам.




## Complex Instruction Set Computer
CISC - это компьютерная архитектура, в которой отдельные инструкции могут выполнять несколько операций низкого уровня (загрузка из памяти, арифметическая операция и сохранение в памяти) или способны выполнять многошаговые операции или режимы адресации в рамках отдельных инструкций.

Методика построения системы команд CISC противостоит методике, применяемой в другом распространённом типе процессорных архитектур — RISC, где используется набор упрощённых инструкций. Типичными представителями CISC-архитектуры являются процессоры на основе команд x86, процессоры Motorola MC680x0, Zilog Z80, процессоры мейнфреймов zSeries.

В конце 1970, когда началась разработка CISC-процессоров, память была очень дорогой. Компиляторы тоже были плохие, а люди писали на ассемблере.
Так как память была дорогой, люди искали способ минимизировать использование памяти. Одно из таких решений — использовать сложные инструкции процессора, которые делают много действий. Это также помогло программистам на ассемблере, так как они смогли писать более простые программы, ведь всегда найдется инструкция, которая выполняет то, что нужно. Через некоторое время это стало сложным. Проектирование декодеров для таких команд стало существенной проблемой. Изначально ее решили с помощью микрокода.

Архитектура CISC в значительной степени стала возможна благодаря возможностям микропрограммного управления. Микропрограмма позволяет относительно легко (по сравнению с разработкой аппаратуры) формировать большое количество команд со сложным поведением. Поднять уровень машинных инструкций ближе к уровню языков программирования высокого уровня. К примеру:

+ относительно легко поддержать все интересующие варианты адресаций для всех типов команд;
+ реализовать операции с произвольным набором аргументов, к примеру, инструкцию для расчета многочленов в рамках одной инструкции;
+ реализовать операции, работающие в потоковом режиме.

Основными преимуществами такого подхода являются:

+ удобство использования ассемблера как инструмента программирования;
+ сокращение затрат на доступ к памяти команд, так как гибкость позволяет сократить количество инструкций;
+ возможность обновления микропрограммного управления позволяет обновить "прошивку" процессора, и тем самым улучшить его функциональность уже после производства аппаратуры;
  + Существуют семейства процессоров и инструментальных средств для них, активно эксплуатирующие данную возможность, к примеру: УВК «Самсон» – базовая ЭВМ РВСН. Оптимизация микрокода под конкретный алгоритм позволяет сократить объём программ (машинное представление), а также оптимизировать лишние операции.

Но также он сопряжён с рядом недостатков:

+ Необходимо хранить микрокод непосредственно в процессоре (необходим мгновенный доступ к нему), где хранение данных --- весьма дорогой процесс, по сравнению с внешней памятью. Чем сложнее система команд, тем больше необходимо памяти.
+ Развитый ассемблер требует большого объёма знаний о процессоре от разработчика. Кроме того, лёгкость развития и модернизации системы команд провоцирует рост разнообразия процессорных архитектур, что, в свою очередь, накладывает серьёзные требования на инструментальные средства.
+ Наличие большого количества программного обеспечения (пусть и в виде микрокода) сопряжено со всеми сложностями программирования. В данном случае это означает, что программное обеспечение нуждается в дорогостоящей отладке и оптимизации, что значительно повышает стоимость разработки.
+ Большое разнообразие команд делает их относительно уникальными с точки зрения формата, размера команды, длительности исполнения и количества доступов к памяти. Как следствие это усложняет:

  + реализацию оптимизаций в рамках процессора (конвейерное исполнение, суперскалярность и т.п.);
  + поддержку со стороны инструментальных средств (компиляторы, дизассемблеры, отладчики и т.п.), в качестве примера можно посмотреть о сложностях разработки дизассемблеров для современных процессоров x86.

Примечание: CISC процессор необязательно нуждается в микрокоде, но, как правило, подразумевает его наличие.

![image](https://github.com/user-attachments/assets/dfef9295-5e10-4c20-bb4e-d61195965884)

## Microcode

Микроко́д — программа, реализующая набор инструкций процессора. Так же, как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в процессоре, использующем микрокод, каждая машинная инструкция реализуется в виде серии микроинструкций — микропрограммы, микрокода. В проектировании процессоров микрокод служит промежуточным слоем, расположенным между аппаратным обеспечением центрального процессора (CPU) и видимой программисту архитектурой набора инструкций компьютера, также известной как машинный код.

Микрокод хранится в ROM-памяти (Read-Only Memory, только для чтения), которая значительно дешевле оперативной памяти. Следовательно, уменьшение использования оперативной памяти через увеличение использования постоянной памяти — выгодный компромисс.

Микрокод, размещённый в специальной высокоскоростной памяти, преобразует машинные инструкции, данные конечных автоматов или другие входные данные в последовательности детализированных операций на уровне схем. Он отделяет машинные инструкции от базовой электроники, обеспечивая тем самым большую гибкость в проектировании и изменении инструкций. Кроме того, микрокод облегчает реализацию сложных многошаговых инструкций, одновременно снижая сложность компьютерных схем. Процесс написания микрокода часто называют микропрограммированием, а сам микрокод в конкретной реализации процессора иногда называют микропрограммой.

Основная идея микрокода заключается в замене специализированной аппаратной логики, реализующей последовательность выполнения инструкций, серией простых инструкций, выполняемых в так называемом "движке микрокода", встроенном в процессор. В то время как специализированная логическая система может состоять из диодов и логических элементов, подающих определённые напряжения на различные управляющие линии, движок микрокода подключается к этим линиям и включает или отключает их по мере последовательного чтения инструкций микрокода. Инструкции микрокода часто кодируются по битам в соответствии с этими линиями: например, если бит 8 установлен в единицу, это может означать, что арифметико-логическое устройство (ALU) должно приостановиться в ожидании данных. В этом смысле микрокод чем-то напоминает перфорированные рулоны в механическом пианино, где отверстия обозначают, какую клавишу следует нажать.

Первые процессоры могли быть реализованы полностью на аппаратном уровне. Основным инструментом программирования являлся ассемблер --- низкоуровневый язык программирования, непосредственно отображаемый на систему команд процессора. У разработчиков был запрос на:

+ высокую производительность;
+ удобство программирования.

Традиционный на сегодня метод повышения удобства программирования через введение абстракций приводил к:

+ высоким накладным расходам (использование подпрограмм);
+ раздуванию исходного кода (inline).

Поэтому одним из путей улучшения user-experience стало наращивание системы команд с целью естественной реализации всех необходимых инструкций. Причем данное наращивание было связано не только и не столько с добавлением новых арифметических операций, сколько с созданием большого количества типовых команд. К примеру: команды, позволяющие использовать большее количество аргументов или сохранять результат не в регистр, а сразу в память и т.п. Как следствие --- для множества команд нет необходимости добавлять новую логику в процессор (шины данных, регистры, сигнальные линии), необходимо только специфическим образом использовать уже имеющуюся.

![image](https://github.com/user-attachments/assets/f704fdda-cc5a-4af7-a52e-a45a44fde78e)

Инструкции прибывают из памяти, обычно из высокоскоростного кеша. Далее они входят в декодер, который разбивает каждую инструкцию на одну или несколько микроопераций. Хотя они выполняют меньше одной инструкции, они значительно больше.
Следствие --- необходимость "программирования" системы команд процессоров, что вылилось в понятие микрокода --- программы, реализующей набор инструкций процессора. К примеру (Wikipedia):

+ Подсоединить регистр 1 ко входу A АЛУ;
+ Подсоединить регистр 7 ко входу B АЛУ;
+ Настроить АЛУ на выполнение операции сложения;
+ Установить разряд переноса АЛУ в ноль;
+ Сохранить результат операции в регистр 8;
+ Обновить коды состояния из флагов АЛУ («Отрицательное», «Ноль», «Переполнение», «Перенос»);
+ Установить указатель микрокоманд на микроинструкцию номер nnn.

Первоначально микрокод был использован в качестве более простого способа разработки управляющего устройства процессора. Прежде набор инструкций задавался жёстко, каждая машинная инструкция (сложение, сдвиг, копирование) реализовывалась непосредственно в схеме. Это давало высокую скорость, но по мере того, как набор инструкций рос, всё сложнее становилось реализовывать в виде схемы и отлаживать инструкции всё возрастающей сложности. Микрокод смягчил эту проблему тем, что позволил инженерам-проектировщикам при реализации сложной инструкции заменить создание сложной схемы на написание микропрограммы. Более того, микрокод можно было с лёгкостью изменить на поздних этапах проектирования, схему же изменить намного сложнее. Таким образом, микрокод облегчил проектирование процессоров, что привело к усложнению набора команд.

Примечания:

+ Как продать свой процессор? Нужно показать классный код на ассемблере.
+ Xerox Alto - один из знаковых компьютеров, предоставляющий программисту уровень микропрограммирования. Тот самый компьютер от Xerox wiki, Alto: A personal computer.

## NISC

Каким образом можно дальше упростить RISC-процессор? Самое простое и неочевидное решение --- угроза из-за его системной команды, как такая, обеспечившая на уровне машинного кода прямой доступ к сигналам и элементам процессора.

No instruction set computing (NISC) - это вычислительная архитектура и технология компиляции для проектирования высокоэффективных специализированных процессоров и аппаратных ускорителей, позволяющая компилятору осуществлять низкоуровневый контроль над аппаратными ресурсами. NISC (No Instruction Set Computer) не использует заранее определённый набор команд или микрокод. Компилятор генерирует нанокоды для непосредственного управления набором команд или микрокодом.

![image](https://github.com/user-attachments/assets/0132f08e-c08b-428a-873d-ac8af08ba029)

Что это позволяет сделать:

+ ISA как уровень абстракции и фактически достигает того уровня контроля за процессором, который есть в микрокоде (фактически получается программа микропрограммы, единая на всем алгоритме), что позволяет сократить количество команд (не по объему, так как из-за большого количества сигналов, как правило, программа становится больше по объему) и накладные расходы на их выполнение;
значительно упрощенный процессор, оставив в нем только те элементы, которые необходимы для вычислительных задач, перенеся, все, что возможно, в компилятор;
+ упрощение разработки процессоров, так как ограничивается сложный и трудоемкий этап проектирования ISA, но в то же время и проявляется крест на бинарной совместимости между различными процессорами (что некритично для систем на кристалле, а также для специализированного под задаче оборудования);
+ Простое определение процессора устройства позволяет сравнительно легко снизить сам процессор под задачу (допустимо для ПЛИС), а также этим обусловлено применение данной структуры в рамках [высокоуровневого синтеза](https://www.youtube.com/watch?v=mbheV9V8AbM) [( слайды )](https://drive.google.com/file/d/161Lj0fVLHgSYLQMaz0Sn_3TaYUGWYvNI/view).

## Стековые процессоры
