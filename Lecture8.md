## Обзор ISA 

---
Ссылки:

[Instruction Set Architecture](https://edizsaykol.weebly.com/uploads/9/8/6/5/9865252/lecture_02_architecture_overview.pdf)

[Архитектура Фон-Неймана, курс лекций "Архитектура ЭВМ и язык Ассемблера" факультета Вычислительной математики и кибернетики Московского Государственного университета им. М. В. Ломоносова](http://arch32.cs.msu.su/Text/Chapter_02.pdf)

---

### Аккумуляторная архитектура

Аккумуляторная архитектура возникла одной из первых, потому очень проста. В ней для хранения одного из операндов арифметической или логической операции в процессоре имеется выделенный регистр --- аккумулятор. В этот же регистр заносится и результат операции. Изначально оба операнда хранятся в основной памяти,и до выполнения операции один из них нужно загрузить в аккумулятор. После выполнения команды обработки результат находится в аккумуляторе и, если он не является операндом для последующей команды, его требуется сохранить в ячейке памяти.

Основные компоненты такой архитектуры включают:

- Память --- для считывания и записи данных;

- АЛУ (арифметико-логическое устройство) --- для выполнения операций;

- Аккумулятор --- специальная ячейка памяти, в которую можно многократно накапливать значения, изменяя их на основе ранее сохранённых данных.

![Пример аккумуляторной архитектуры](вот сюда нужны наши фото)

**Пример выполнения вычислений**

В качестве примера рассматривается реализация классической линейной функции: 

`A = B + (C * D)`

```
load ACC <- C.
mul ACC <-* D
add ACC <-+ B
store A <- ACC
```

Процесс вычисления в аккумуляторной архитектуре выглядит следующим образом:

1. Инициализация аккумулятора значением переменной `C`.

2. Умножение содержимого аккумулятора на значение переменной `D`.

3. Прибавление к аккумулятору значения переменной `B`.

4. Сохранение конечного результата в адрес памяти, соответствующий переменной `A`.

Таким образом, весь вычислительный процесс строится вокруг последовательной работы с аккумулятором через простые шаги.

**Преимущества аккумуляторной архитектуры**

- Простота системы команд. Архитектура подразумевает минимальный набор инструкций: аккумулятор (неявный аргумент) и адрес памяти (явный аргумент).

- Компактность инструкций. Инструкции имеют фиксированный размер и малый объём.

- Простота аппаратной реализации. Реализация процессора становится крайне простой; основная сложность заключается лишь в организации работы с памятью.

**Ограничения аккумуляторной архитектуры**

Одним из ограничений является необходимость частой работы с памятью. Например, если бы в формуле использовалось другое действие: `E = (A * B) + (C * D)` , то для хранения промежуточного результата понадобилась бы дополнительная ячейка памяти, так как аккумулятор смог бы удержать только одно промежуточное значение.

### Register-to-Memory

Микропроцессор с архитектурой данного типа включает в себя массив регистров, известных как регистры общего назначения. В микропроцессоре отсутствует специальный регистр данных, выполняющий функции аккумулятора. Функции аккумулятора выполняет один из регистров общего назначения. Размер регистров обычно фиксирован и совпадает с размером машинного слова. К любому регистру можно обратиться, указав его номер. Регистровая архитектура допускает расположение операндов в одном из двух пространств: основной памяти или регистрах. С учетом возможного размещения операндов в рамках регистровых архитектур выделяют три типа команд обработки: Register-to-Register, Register-to-Memory, Memory-to-Memory.

![Пример Register-to-Memory архитектуры](вот сюда нужны наши фото)

**Основные особенности:**

- Увеличение числа регистров. Множество регистров позволяет снизить нагрузку на память. Нет необходимости постоянно считывать и записывать данные между памятью и аккумулятором.Данные обрабатываются непосредственно в регистрах.

- Расширение системы команд. Один операнд указывает на регистр, с которым происходит операция. Два операнда позволяют разделить регистр-источник и регистр-назначение, повышая гибкость операций.

Рассмотрим задачу инкрементации массива чисел на фиксированное значение (например, на 2):

1. Значение `2` загружается в регистр `R0`.

2. Одно из значений массива загружается в регистр `R1`.

3. Выполняется сложение содержимого `R0` и `R1`.

4. Результат сохраняется в регистр `R2`.

5. Операции повторяются для всех элементов массива в цикле.

Архитектуры Accumulator и Register-to-Memory сыграли ключевую роль в становлении и развитии вычислительных систем. Их популярность была обусловлена рядом существенных преимуществ, например, простота реализации на аппаратном уровне, что делало их особенно привлекательными для ранних поколений компьютеров. Эти архитектуры отличались также ясной и интуитивно понятной моделью программирования, которая упрощает процесс написания и понимания машинного кода. Несмотря на свою относительную техническую скромность, они обеспечивали достаточную вычислительную эффективность для решения широкого спектра базовых задач, что сделало их надёжным фундаментом для дальнейших архитектурных разработок в мире вычислительной техники.

Элементы **Register-to-Memory** архитектуры используются и в современных процессорах: многие современные архитектуры типа **CISC** во многом опираются на эти принципы.

### Register-to-Register

В архитектуре Register-to-Memory на каждом такте выполняется доступ к памяти. Это является серьёзным недостатком, поскольку память почти всегда работает значительно медленнее, чем процессор и, тем более, чем регистры.

Одной из ключевых проблем в архитектуре вычислительных систем является несоответствие скоростей между процессором и оперативной памятью. Современные процессоры работают на значительно более высоких частотах, чем память, что приводит к возникновению задержек при обращении к данным. Регистры процессора обеспечивают практически мгновенный доступ к информации, тогда как обращение к основной памяти может занимать гораздо больше времени. Для смягчения этого разрыва в производительности применяется механизм кэширования. Кэш-память --- это высокоскоростной буфер между процессором и оперативной памятью, предназначенный для хранения наиболее часто используемых данных. При наличии нужной информации в кэше доступ осуществляется быстро и эффективно. Однако, в случае промаха кэша --- когда данные отсутствуют в кэше --- происходит обращение к основной памяти, что вновь сопровождается ощутимыми задержками. Таким образом, проблема скорости доступа к памяти остаётся актуальной, несмотря на развитие кэш-архитектур и оптимизационных технологий.

По мере увеличения разрыва между скоростью процессоров и памяти возникла задача: Как сделать так, чтобы обращения к памяти происходили как можно реже?

Решением стало развитие архитектуры, в которой все операции выполняются исключительно на регистрах.

Архитектура типа Register-to-Register строится на ряде чётко определённых принципов, обеспечивающих эффективность и структурированность вычислительного процесса. В первую очередь, все необходимые данные предварительно загружаются из оперативной памяти в регистры процессора. Это позволяет минимизировать количество обращений к относительно медленной памяти во время выполнения операций. Далее, все арифметические и логические вычисления происходят исключительно между регистрами, что существенно ускоряет обработку данных за счёт высокой скорости работы с регистрами. Завершающим этапом является сохранение полученных результатов обратно в память, если они необходимы за пределами текущих вычислений. Такой подход делает Register-to-Register архитектуру особенно эффективной для современных высокопроизводительных систем, где критически важна скорость обработки и строгое разделение стадий загрузки, вычислений и сохранения данных.

![Пример Register-to-Register архитектуры](вот сюда нужны наши фото)

**Преимущества Register-to-Register архитектуры:**

- Высокая скорость выполнения операций. Операции на регистрах происходят значительно быстрее, так как регистры имеют мгновенный доступ.

- Эффективная схемотехника. Поскольку регистров ограниченное количество, их можно эффективно связать мультиплексорами для быстрого выбора нужных данных.

-  Минимизация времени выполнения инструкций. Инструкции, работающие только с регистрами, могут выполняться за очень малое количество тактов (порой менее чем за два такта).

-  Компактность инструкций. Для адресации регистров требуется значительно меньше бит по сравнению с адресацией памяти. Например, если доступно 32 регистра, для указания каждого понадобится всего 5 бит. Таким образом, для указания двух операндов и результата достаточно 15 бит, а оставшееся место в инструкции используется для кодирования операции (опкода).

**Пример системы команд и линейной функции Y = A * X + B:**

```
load R1 <- A      
load R2 <- X      
load R3 <- В
mul R4 <- R1 * R2
add R5 <- R4 + R3
store Y <- R5
```

Здесь о мы чётко разделили операции работы с памятью и операции вычислений между регистрами. На первом этапе данные из оперативной памяти загружаются в регистры с помощью отдельных инструкций load. Затем все вычисления — будь то арифметические или логические — выполняются исключительно между регистрами, без участия памяти. После завершения обработки результаты записываются обратно в память с использованием команды store. Такой подход, несмотря на некоторое увеличение объёма машинного кода, дал целый ряд ощутимых преимуществ. Он упростил разграничение вычислительных процессов и операций обращения к памяти, сделав архитектуру более прозрачной и предсказуемой. Кроме того, это позволило эффективнее использовать параллелизм: пока одни данные загружаются, другие могут одновременно обрабатываться в регистрах. А благодаря тому, что операции теперь работают только с регистрами, многие из них стали короче, быстрее и проще как для аппаратной реализации, так и для компиляции. Всё это делает Register-to-Register архитектуру мощным инструментом в создании современных производительных процессоров.

В общем, потеряли в компактности кода, но выиграли в чёткости структуры и потенциальной скорости выполнения.

### Memory-to-Memory

После развития аккумуляторной и Register-to-Memory архитектур появились новые направления в организации вычислений, требующие ещё более глубокого управления памятью и инструкциями.

Одним из альтернативных направлений развития компьютерной архитектуры стала модель Memory-to-Memory. В отличие от Register-to-Register подхода, где все вычисления происходят только между регистрами, эта архитектура позволяет инструкциям напрямую взаимодействовать с ячейками оперативной памяти. Каждая операция здесь может включать сразу несколько этапов: считывание исходных данных из одной области памяти, выполнение вычислений внутри процессора и запись полученного результата обратно в другую область памяти. Таким образом, одна инструкция совмещает в себе сразу три действия — загрузку, обработку и сохранение — что делает машинный код более компактным. Такой подход упрощает программирование на низком уровне и уменьшает количество промежуточных шагов, хотя и может снижать производительность из-за постоянного обращения к памяти, которая работает медленнее регистров. Тем не менее, Memory-to-Memory архитектура остаётся интересной с точки зрения гибкости и лаконичности выражения операций.

![Пример Memory-to-Memory архитектуры](вот сюда нужны наши фото)

**Преимущества Memory-to-Memory архитектуры:**

- Удобство для низкоуровневого программирования. При разработке на ассемблере Memory-to-Memory архитектура позволяет писать код, который напрямую отражает алгоритмическую суть программы.

- Эффективность инструкций. Одна инструкция выполняет сразу несколько операций, что уменьшает накладные расходы на кодирование и интерпретацию инструкций.

- Читаемость и простота отладки. Программы на такой архитектуре легко читаются, а псевдокод высокого уровня можно почти напрямую транслировать в машинные инструкции.


**Недостатки Memory-to-Memory архитектуры:**

- Большое количество обращений к памяти. Частые операции чтения и записи в память замедляют выполнение программы, особенно с учётом того, что скорость памяти растёт медленнее, чем скорость процессоров.

- Ограниченная эффективность кэширования. Кэш-память частично помогает, но полностью проблему задержек при доступе к памяти устранить невозможно.

- Сложность системы команд. Архитектура Memory-to-Memory порождает богатую и разнообразную систему команд. Инструкции быстро обрастают дополнительной функциональностью (например, "прочитать и инкрементировать"). Реализация такой сложной логики на уровне аппаратуры требует значительных затрат ресурсов и времени.


**Пример системы команд и линейной функции Y = A * X + B:**

```
lnf Y<- A * X + B   ; mem-to-mem
                    ; 3 operands 
```

Процесс выполнения инструкции можно представить следующим образом: сначала процессор считывает значения из двух ячеек памяти — `A` и `X`, после чего выполняет умножение этих значений. Затем из памяти извлекается значение `B`, которое прибавляется к результату предыдущей операции. Полученное значение записывается обратно в память по адресу `Y`. Таким образом, одна единственная инструкция охватывает сразу три этапа: чтение данных из памяти, вычисление результата внутри процессора и запись результата обратно в память.

### Стековая архитектура

Отдельным направлением развития стала стековая архитектура. Стековая архитектура отличается компактностью команд и особенно эффективна для определённых типов вычислений (например, при реализации языков программирования с выражениями в польской записи). В её основе лежит принцип использования стековой памяти, размещённой непосредственно внутри процессора, вместо традиционного набора регистров. Стек представляет собой совокупность связанных между собой ячеек памяти, функционирующих по принципу «последним вошёл --- первым вышел» (LIFO, Last In First Out), что позволяет обращаться исключительно к элементу, находящемуся на вершине стека. Соответственно, в стековой архитектуре аргументы явно не указываются, а используются данные, размещённые на вершине стека.

![Пример Стековой архитектуры](вот сюда нужны наши фото)

**Преимущества стековой архитектуры**:

- Естественная поддержка процедур. Аргументы функций передаются посредством стека без необходимости использования ограниченного числа регистров, что особенно актуально при глубокой вложенности вызовов. Это избавляет от необходимости введения соглашений об использовании регистров, все необходимые данные просто помещаются в стек.
- Простота реализации. Стековая архитектура характеризуется простотой реализации и минималистичным машинным кодом, что упрощает проектирование процессоров.

**Недостатки стековой архитектуры**:

- Неудобство произвольного доступа. В случае необходимости обращения к элементам стека, расположенным не на вершине, возникает необходимость выполнения дополнительных операций, что приводит к увеличению количества команд. Для частичного решения этой проблемы могут использоваться несколько стеков или дополнительные регистры.

- Сложности в оптимизации. Ограничение работы только с вершиной стека затрудняет распараллеливание операций, что снижает производительность и ограничивает возможности ускорения выполнения программ.

Стековые процессоры часто применяются в реализации интерпретаторов, поскольку построение виртуальных машин на основе стека является удобным и эффективным решением.

**Пример системы команд и линейной функции Y = A * X + B:**

```
A @ X @ *   \ stack, 0 operands
B @ + Y !   \ @ - read, ! - write 
```

* `@` --- операция чтения: извлекает значение из памяти по указанному адресу и помещает его на вершину стека;
* `*`, `+` --- арифметические операции: берут два верхних значения со стека, применяют операцию и помещают результат обратно;
* `!` --- операция записи: снимает значение с вершины стека и сохраняет его в указанную ячейку памяти.

Пошаговое выполнение:

1. `A @` — считывает значение из памяти по адресу `A` и помещает его на стек;
2. `X @` — аналогично, значение из `X` добавляется на вершину стека;
3. `*` — перемножает два верхних значения (то есть `A * X`) и кладёт результат обратно;
4. `B @` — значение из памяти по адресу `B` загружается в стек;
5. `+` — складывает два верхних значения (`A * X + B`);
6. `Y !` — сохраняет итоговое значение в память по адресу `Y`.

## Машина фон-Неймана

### Характеристики
Машина фон Неймана представляет собой абстрактную модель вычислительной системы, поскольку многие элементы её архитектуры изначально не были конкретизированы. Это сделано намеренно, чтобы не ограничивать творческий подход инженеров-разработчиков при создании новых ЭВМ. Таким образом, архитектура машины фон Неймана описана не на уровне внутренней реализации, а на концептуальном уровне представления вычислительного процесса.

Рассмотрим более конкретную организацию архитектуры фон Неймана:

![Машина фон Неймана](fig/von-neumann-example.png)

Описание:

- Разрядность процессора: 8 бит.
- Организация памяти: гарвардская, с отдельными блоками памяти для команд и данных.
- Внешние устройства (для данной работы это светодиоды, двухпозиционные переключатели и тактовые кнопки) отображаются в адресное пространство данных. Работа с ними выполняется по опросу.
- Регистры:
    - `PC` --- регистр счётчика команд (Program Counter) указывает адрес текущей инструкции, при этом общее количество возможных инструкций составляет 256.
    - `IR` --- регистр инструкций (Instruction Register), предназначен для хранения активной команды или операционного кода, поступающего из памяти команд.
    - `AR` --- регистр адреса операнда (Address Register) содержит адрес памяти, который будет использован в следующих тактах.
    - `C` --- флаг переноса/заёма
    - `Z` --- флаг нуля
- Команды выполняются за 2 или 3 такта (в зависимости от типа команды):
    1. Выборка команды
    2. Выборка операндов
    3. Выполнение команды.
- Подсистема обработки прерываний и команды вызова подпрограмм отсутствует.
- В архитектуре предусмотрен мультиплексор (MUX2), который позволяет выбирать источник данных для левого входа арифметико-логического устройства (АЛУ): либо данные из памяти данных, либо данные из памяти команд. Второй аргумент для АЛУ поступает исключительно из аккумулятора, в который затем записывается результат вычислений.

[Пример модели процессора на Haskell](http://amazing-new-gate.blogspot.com/2010/07/haskell.html)

### Пример исполнения инструкции

Код на ассемблере:

```
add #01 <- 34 + #03
асс <- 34
асс <-  #03.
#01 <- acc
```

Потактовое исполнение:

```

; --- 1. Чтение инструкции

IR <- PMem[ PC]
PC <- PC+1

; --- 2. Инициализация акк. 34

{ Acc, Z, C } <- ALU( ... )
              <-  MUX2( ... )
              <- PMem [PC]
PC + PC+1

; --- 3. Выгрузка адреса 03

AR <- PMem[ PC]
PC <- PC+1

; --- 4. Выгрузка адреса 01 
; ---     Выгрузка #03 и сложение

AR <- PMem[PC]
{ Acc, Z, C } <- ALU( ... )
              <- MUX2 ( ... ) 
              <- DMem[AR].DOUT
PC <- PC+1

; --- 5. Сохранение результата

DMem[AR].DIN <- Acc
```

Итак, что вообще происходит в нашем примере с операцией `ADD #01 <- 34 + #03`?

Нам нужно прочитать значение из ячейки по адресу `03`, прибавить к нему число `34`, и сохранить результат в адрес `01`. В инструкции закодировано всё необходимое: операционный код и три аргумента (34, 03 и 01). Уже видно: **четыре байта**. Почему? Можно было бы экономить и обойтись компактнее. Но в данном случае решили явно всё расписывать, без ограничений восьмибитной адресации — чтобы было наглядно.

Первым идёт **операционный код** --- он сообщает устройству управления, какой **набор управляющих сигналов** нужно будет сгенерировать в ближайшие такты. Сразу после кода идут **аргументы**: константа `34`, адрес первого операнда `03`, и адрес сохранения результата `01`.

Что бы изменилось, если бы использовали классическую аккумуляторную архитектуру, а не такую память-регистр систему? Инструкций стало бы три: сначала загрузить константу, потом загрузить из памяти, потом сохранить результат. И было бы **дублирование опкодов**. Нужно три раза писать разные команды вместо одной. Расход памяти вырос бы ещё на два байта, а вычислений стало бы больше —-- вместо пяти тактов нам бы пришлось тратить целых восемь.

Вывод: Код, организованный как в этом примере эффективнее: и быстрее, и компактнее.

Теперь давайте последовательно пройдём весь процесс выполнения:

Первое действие --- **чтение инструкции**.  
Программный счётчик (`PC`) указывает на нужную команду. Память команд (`PMem`) --- комбинационная схема: подаём адрес на вход, на выходе сразу появляется соответствующий байт. 
Мы защёлкиваем его в регистре инструкции (`IR`) и **инкрементируем `PC`**. Почему сразу? Потому что через такт нам нужно будет читать следующий байт --- первый аргумент.

**Если бы не сделали инкремент вовремя — всё бы сломалось.**

Второй такт --- **инициализация аккумулятора**.  
Мы читаем `34` из памяти команд, через мультиплексор подаём его на вход ALU, и пишем в аккумулятор. 
ALU отрабатывает как комбинационная схема: получили вход —-- сразу получили выход. Опять же, **инкрементируем `PC`** для подготовки к следующему байту.

**Замечание:** Почему данные из памяти команд **не защёлкиваются** в адресном регистре (`AR`) в эти моменты? Потому что нет управляющего сигнала защёлки.

Третий такт --- **чтение первого адреса**.  
Теперь `PMem[PC]` даёт нам `03`. Это адрес первого операнда. Мы защёлкиваем его в `AR`. Опять инкрементирует `PC`. Отдельно данные, отдельно управление.

Четвёртый такт --- **чтение второго адреса и сложение**.  
Читаем `01` --- адрес, куда потом сохранять результат. Его защёлкиваем в `AR`. Одновременно ALU складывает: на одном входе --- значение из аккумулятора (`34`), на другом --- данные из памяти данных (`DMem`) по адресу `03`. Выход ALU сразу защёлкиваем в аккумулятор. Опять плюс один к `PC`, чтобы быть готовыми к следующей инструкции.

**Важный момент:** процессы тут идут параллельно, а не последовательно. Пока данные ещё "ползут" по шинам, некоторые узлы уже отрабатывают свои задачи. Это принципиально важно для понимания работы железа.

Пятый такт --- **сохранение результата**.  
Из аккумулятора через шину данных значение отправляется в память данных (`DMem`) по адресу, который в `AR`. И параллельно считывает следующую инструкцию из памяти команд, продолжая инкрементировать `PC`.

**Что это нам даёт?**  
Перекрытие инструкций. Последний такт текущей команды и первый такт следующей идут **в один** момент. Меньше холостого времени, быстрее выполнение.


В чём ценность этой схемы?

- Видим, как реально работают процессоры.
- Понимаем, что разные системы команд дают разные результаты: одни медленные и тяжёлые, другие быстрые и экономные.
- Маленькие архитектурные решения напрямую влияют на производительность и структуру кода.

В нашем случае переход от классической аккумуляторной архитектуры к такой памяти-регистр схеме делает процессор быстрее, легче и эффективнее почти без изменения "железа", только за счёт более разумного управления.

Вот так на практике и рождаются системы типа **CISC** --- Complex Instruction Set Computer.


## Complex Instruction Set Computer

**Complex Instruction Set Computing (CISC)** --- архитектура процессора с полным набором команд, в которой отдельные инструкции способны выполнять несколько операций низкого уровня (например, загрузку из памяти, арифметические вычисления и сохранение обратно в память) или многошаговые процедуры в рамках одной инструкции. Основоположником CISC-архитектуры считается компания IBM с архитектурой IBM/360. Типичными примерами CISC-процессоров являются x86, Motorola MC680x0, Zilog Z80 и мейнфреймы серии zSeries.

Основная идея CISC заключалась в стремлении обеспечить максимально эффективное управление процессором. Для этого систему команд усложнили, чтобы минимизировать количество лишних операций при выполнении задач. Архитектура стремилась к тому, чтобы каждая типовая операция обработки данных имела свою специализированную машинную команду. Это позволило упростить процесс программирования на низкоуровневых языках и существенно сократить объем разрабатываемого кода.

Одним из факторов, способствовавших развитию CISC, стало внедрение микропрограммного управления. Микропрограммы позволяли сравнительно просто формировать сложные команды и расширенные режимы адресации без значительных затрат на аппаратную реализацию. Благодаря этому стало возможным:

- поддерживать различные режимы адресации для всех типов команд;
- реализовывать сложные арифметические операции в рамках одной инструкции;
- создавать потоковые операции обработки данных.

Микропрограммное управление также обеспечивало возможность обновления и оптимизации работы процессора после его выпуска за счёт изменения микрокода, как это было реализовано, например, в системах семейства УВК «Самсон» для РВСН.


**Причины появления архитектуры CISC**

- **Низкоуровневые языки:** На момент появления CISC-процессоров высокоуровневые языки ещё не получили широкого распространения. Программирование велось преимущественно на ассемблере, и наличие расширенного набора команд облегчало написание кода.

- **Разнообразие архитектур:** Существенные различия между архитектурами затрудняли переносимость программ. Универсальные и мощные команды помогали нивелировать эти различия.

- **Неразвитость компиляторов:** Ограниченные возможности компиляторов вынуждали перекладывать задачи оптимизации программ на процессоры с расширенным набором инструкций.

- **Удобство программирования:** Большое количество мощных команд позволяло уменьшить объём кода и упростить его разработку.

- **Высокая производительность:** Многофункциональные инструкции обеспечивали выполнение сложных операций за один цикл программной логики, повышая эффективность без дополнительных оптимизаций.

- **Минимизация объёма программ:** Компактные инструкции позволяли экономить дефицитные ресурсы памяти.

- **Минимизация накладных расходов:** Уменьшение количества обращений к памяти и внутренних пересылок данных снижало накладные затраты при выполнении программ.


**Преимущества архитектуры CISC**

- Удобство использования ассемблера для написания программ.
- Снижение затрат на доступ к памяти команд благодаря более коротким программам.
- Возможность обновления микрокода для улучшения функциональности процессора.
- Возможность оптимизации микрокода для конкретных алгоритмов, сокращение объема программ и устранение лишних операций.


**Проблемы архитектуры CISC**

- **Сложность системы команд:** Большое количество команд делает их полное освоение и эффективное использование сложной задачей для программистов и компиляторов.

- **Усложнение устройства процессора и блока управления:** Наличие множества инструкций, способов адресации и аргументов приводит к значительному усложнению схем управления процессором.

- **Сложность генерации эффективного машинного кода:** Автоматические компиляторы испытывают трудности в создании оптимального кода для CISC-процессоров.

- **Высокая стоимость хранения микрокода:** Микропрограммы требуют размещения в быстрой внутренней памяти процессора, что увеличивает стоимость чипа.

- **Повышенные требования к разработчикам:** Разработка и сопровождение сложных систем команд требуют глубоких знаний архитектуры процессора.

- **Сложности оптимизации производительности:** Большое разнообразие команд и их неоднородность затрудняют реализацию высокоэффективных методов обработки, таких как конвейеризация и суперскалярность.

- **Высокая стоимость разработки микрокода:** Программирование микрокода требует значительных затрат на отладку и оптимизацию.

Несмотря на выявленные недостатки, архитектура CISC продолжает активно использоваться ведущими производителями процессоров (Intel, AMD, IBM). В современных CISC-процессорах применяются гибридные подходы, сочетающие принципы CISC и RISC для достижения максимальной производительности.

![CISC](fig/cisc.png){ width=50% }


**Пример системы команд и линейной функции Y = A * X + B:**

```
load R1 <- A          ; reg-to-reg
load R2 <- X          ; 3 operands
load R3 <- B
lnf R4 < -R1 * R2 + R3
store Y <- R4
```

Здесь применена сложная инструкция, которая сразу вычисляет линейную функцию в рамках одной команды.

Такой подход характерен для специализированных процессоров, где известно, что необходимо выполнять множество однотипных линейных функций. Реализация подобных операций на уровне аппаратуры процессора даёт ряд преимуществ:

 - Несмотря на увеличение набора инструкций, каждую такую операцию можно оптимизировать на уровне микрокода или схемотехники для максимально быстрого исполнения.

 - Минимизируется количество обращений к памяти и регистрам: все необходимые данные загружаются заранее, после чего выполняется сразу полное вычисление.

 - Уменьшается общий объём машинного кода за счёт высокой плотности операций.

 - Снижается нагрузка на шину данных, так как не требуется дополнительной загрузки промежуточных результатов.

В результате получается максимально компактный и быстрый код, что особенно важно в задачах с большим числом однотипных вычислений.

---

Ссылки:

[CISC](https://web.archive.org/web/20180925234153/http://www.nsc.ru/win/elbib/data/show_page.dhtml?77+739)

---

## Microcode

При проектировании CISC-процессоров приоритетным направлением является разработка устройства процессора и блока управления (Control Unit), поскольку реализация конечного автомата, способного поддерживать сложную систему команд, представляет собой исключительно сложную задачу с аппаратной точки зрения.

Существует два основных подхода к реализации Control Unit:

- **Hardwired (жёстко заданный)** --- управление реализуется через комбинационные схемы, декодирующие инструкции в последовательности управляющих сигналов. Блок управления использует фиксированный набор логических вентилей и схем, при этом каждая инструкция имеет заранее заданную жёсткую реализацию. Hardwired-блоки просты и быстры, однако они малогибки и трудны для модификации.

- **Microcoded (микропрограммный)** --- управление осуществляется посредством исполнения микропрограммы, управляющей выполнением инструкций. Внутри процессора размещается очень быстрая память, в которой хранится микрокод, управляющий всеми процессами на уровне выполнения инструкций.

**Микрокод** — это программа, реализующая набор инструкций процессора. Подобно тому, как одна инструкция языка высокого уровня преобразуется в серию машинных инструкций, в микрокодируемом процессоре каждая машинная инструкция превращается в последовательность микроинструкций. Микрокод служит промежуточным уровнем между аппаратной реализацией процессора и видимой программисту архитектурой набора инструкций.

Микрокод хранится в памяти только для чтения (**ROM**), которая значительно дешевле оперативной памяти. Это позволяет выгодно использовать постоянную память, снижая потребность в более дорогих компонентах.

Размещённый в специализированной высокоскоростной памяти, микрокод преобразует машинные инструкции или другие входные данные в последовательности детализированных низкоуровневых операций. Микрокод позволяет отделить реализацию инструкций от базовой электроники, обеспечивая гибкость в проектировании и возможностях модификации. Он также упрощает реализацию сложных многошаговых инструкций, одновременно снижая общую сложность аппаратуры.

Процесс написания микрокода называют микропрограммированием. В конкретной реализации процессора микрокод часто называют микропрограммой. Основная идея микрокода заключается в замене специализированной аппаратной логики серией простых микроинструкций, выполняемых движком микрокода. В этом движке каждая микроинструкция последовательно активирует необходимые управляющие сигналы. Микрокод может быть битово закодирован, где каждый бит отвечает за определённую управляющую линию, аналогично тому, как отверстия на перфорированном рулоне механического пианино управляют звучанием клавиш.

Первые процессоры могли быть реализованы полностью аппаратно, а основным языком программирования был ассемблер, напрямую соответствующий системе команд процессора. Разработчики стремились одновременно к высокой производительности и удобству программирования.

Попытки повысить удобство через введение дополнительных абстракций приводили к:

- высоким накладным расходам (например, через активное использование подпрограмм);
- раздуванию исходного кода (например, при широком использовании inline-функций).

Одним из путей улучшения пользовательского опыта стало расширение набора инструкций, позволяющее естественно и без дополнительных накладных расходов реализовывать частые операции. Это расширение включало:

- добавление команд с увеличенным числом аргументов;
- команды для непосредственной работы с памятью без обязательного сохранения результата в регистр.

Как следствие, расширение набора команд не требовало радикальных изменений в архитектуре процессора (таких как новые шины данных или регистры), а лишь специфического использования уже существующих аппаратных ресурсов.

![Микрокод]( fig/microcode-decode.png )

Инструкции прибывают из памяти, обычно из высокоскоростного кеша. Далее они входят в декодер, который разбивает каждую инструкцию на одну или несколько микроопераций. Хотя они выполняют меньше одной инструкции, они значительно больше.
Следствие --- необходимость "программирования" системы команд процессоров, что вылилось в понятие микрокода --- программы, реализующей набор инструкций процессора. К примеру (Wikipedia):

- Подсоединить регистр 1 ко входу A АЛУ;
- Подсоединить регистр 7 ко входу B АЛУ;
- Настроить АЛУ на выполнение операции сложения;
- Установить разряд переноса АЛУ в ноль;
- Сохранить результат операции в регистр 8;
- Обновить коды состояния из флагов АЛУ («Отрицательное», «Ноль», «Переполнение», «Перенос»);
- Установить указатель микрокоманд на микроинструкцию номер nnn.

Первоначально микрокод был использован в качестве более простого способа разработки управляющего устройства процессора. Прежде набор инструкций задавался жёстко, каждая машинная инструкция (сложение, сдвиг, копирование) реализовывалась непосредственно в схеме. Это давало высокую скорость, но по мере того, как набор инструкций рос, всё сложнее становилось реализовывать в виде схемы и отлаживать инструкции всё возрастающей сложности. Микрокод смягчил эту проблему тем, что позволил инженерам-проектировщикам при реализации сложной инструкции заменить создание сложной схемы на написание микропрограммы. Более того, микрокод можно было с лёгкостью изменить на поздних этапах проектирования, схему же изменить намного сложнее. Таким образом, микрокод облегчил проектирование процессоров, что привело к усложнению набора команд.

Примечания:

- Как продать свой процессор? Нужно показать классный код на ассемблере.
- Xerox Alto - один из знаковых компьютеров, предоставляющий программисту уровень микропрограммирования. Тот самый компьютер от Xerox [wiki](https://en.wikipedia.org/wiki/Xerox_Alto), [Alto: A personal computer](http://people.scs.carleton.ca/~soma/distos/fall2008/alto.pdf).

---

Ссылки:

[Microcode](https://en.wikipedia.org/wiki/Microcode#Microcode)

---


## No Instruction Set Computing

**No instruction set computing (NISC)** --- это вычислительная архитектура и технология компиляции для проектирования высокоэффективных специализированных процессоров и аппаратных ускорителей, позволяющая компилятору осуществлять низкоуровневый контроль над аппаратными ресурсами. NISC (No Instruction Set Computer) не использует заранее определённый набор команд или микрокод. Компилятор генерирует нанокоды для непосредственного управления набором команд или микрокодом.

Если мы посмотрим на процессор и зададимся вопросом: "А зачем нам вообще нужны инструкции?", становится очевидным, что процессор в реальности управляется микроинструкциями. Тогда возникает идея: отказаться от этапа компиляции в машинные инструкции и вместо этого компилятору сразу выдавать трассы микроинструкций, которые напрямую загоняются в процессор для управления.

В классическом CISC-процессоре (схема предоставлена в соответсвующем разделе) мы видим:

- Program Counter
- Program Memory
- Micro Program Counter
- Micro Program Memory
- Управляющие слова

Если удалить этап с Micro Program Counter и Micro Program Memory, останется только Program Counter и Program Memory. Это позволяет значительно упростить процессор. Теперь компилятор, понимая что именно он делает, может сразу генерировать оптимальный для конкретной аппаратуры код.

![NISC](fig/nisc.png){ width=50% }

Преимущества такого подхода:

- Значительное упрощение аппаратной части.

- Максимальная эффективность программного управления.

- Отсутствие необходимости в проектировании и поддержке ISA (Instruction Set Architecture), так как управляющие сигналы напрямую задаются железом.

- ISA в таком подходе становится фактически уровнем абстракции, который обеспечивает контроль за процессором на уровне микрокода. Это позволяет сократить количество типов команд (хотя общий объём программы может увеличиваться за счёт количества управляющих сигналов) и снижает накладные расходы на выполнение инструкций.

- Упрощение разработки процессоров: устраняется сложный и трудоёмкий этап проектирования ISA, что особенно важно для специализированного оборудования. Однако одновременно исчезает бинарная совместимость между различными процессорами — что, впрочем, некритично для систем-на-кристалле и узкоспециализированных решений.

- Упрощение структуры процессора: оставляются только элементы, необходимые для выполнения вычислений, а всё возможное переносится на уровень компилятора.

- Благодаря простой структуре процессора становится возможным его сравнительно лёгкая адаптация под конкретные задачи, особенно в системах на ПЛИС (FPGA), что обусловливает применение данной архитектуры в рамках [высокоуровневого синтеза](https://www.youtube.com/watch?v=mbheV9V8AbM) ([слайды](https://drive.google.com/file/d/161Lj0fVLHgSYLQMaz0Sn_3TaYUGWYvNI/view)).

Несмотря на определённые преимущества стековой архитектуры, такие как компактность выражения операций и простота реализации, у неё имеются и существенные недостатки, ограничивающие её широкое применение в современных вычислительных системах.

Во-первых, возникает проблема отсутствия бинарной совместимости. Для корректного исполнения сгенерированного машинного кода требуется, чтобы внутреннее устройство целевого процессора полностью совпадало с тем, для которого этот код был разработан. Это связано с тем, что в стековой архитектуре отсутствует чёткое разделение между архитектурой и микроархитектурой процессора: способ представления команд, структура стека и даже порядок выполнения операций могут быть глубоко привязаны к конкретной реализации. В результате компиляторы, программисты и производители аппаратного обеспечения вынуждены тесно координировать свои действия, что исключает возможность их независимого развития и делает переносимость кода крайне затруднительной.

Во-вторых, данная модель демонстрирует низкую плотность машинного кода. Управляющие слова, используемые для кодирования операций, часто содержат множество нулевых битов, не несущих полезной информации. Эти «пустые» участки загружают внутреннюю память процессора, расходуют ресурсы шин передачи данных и увеличивают объём передаваемой информации. В условиях, когда эффективность работы процессора всё чаще зависит от скорости обмена данными и экономного использования памяти, такие накладные расходы становятся серьёзным ограничением.

На практике для борьбы с низкой плотностью кода иногда применяются аппаратные архиваторы, которые позволяют хранить программу в сжатом виде и распаковывать её на лету. Несмотря на это, подобный подход остаётся экзотическим и применяется в основном в специфических задачах, где процессоры проектируются под конкретное применение.

Есть две основных области применения таких идей:

- **Высокоуровневый синтез (HLS, High-Level Synthesis).** Это специальные САПР-инструменты, которые позволяют на основе программы на языке C автоматически сгенерировать цифровую схему, реализующую алгоритм. Такой подход значительно упрощает проектирование цифровой обработки сигналов и других специализированных вычислений, хотя инструменты HLS остаются сложными в использовании. Под капотом они часто используют низкоуровневую архитектуру: микропрограммное управление плюс датапас, где микропрограмма координирует действия датапаса в зависимости от скомпилированного алгоритма.

- **CGRA-процессоры (Coarse-Grained Reconfigurable Architectures).** Эти архитектуры потенциально представляют будущее вычислительной техники. Мы коснёмся этой темы ближе к концу семестра, в рамках проекта по разработке САПРов для спецпроцессоров.
  
